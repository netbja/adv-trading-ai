{
  "name": "My workflow 2",
  "nodes": [
    {
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "custom",
              "cronExpression": "*/15 * * * *"
            }
          ]
        }
      },
      "id": "c10fa377-194f-4a52-891e-6c103a2c128a",
      "name": "⏰ Trigger Scan (Cron)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        -2680,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "// 🚀 PF: Init/View - VERSION AVEC COHÉRENCE PARFAITE\nconsole.log(\"🚀 Portfolio Init - SIMPLE VERSION\");\n\nconst currentTimestamp = new Date().toISOString();\n\n// Portfolio avec valeurs parfaitement cohérentes\nconst testPortfolio = {\n  balance: 9500, // Balance après achat\n  openPositions: [\n    {\n      id: \"pos_test_scalp_001\",\n      symbol: \"TEST\",\n      name: \"Test Scalping Token\",\n      buyPrice: 0.001,\n      quantity: 500000,\n      timestamp: currentTimestamp,\n      status: \"OPEN\",\n      valueAtBuy: 500,\n      platform: \"pump.fun\",\n      address: \"test123...\"\n    }\n  ],\n  tradeHistory: [\n    {\n      type: \"BUY\",\n      symbol: \"TEST\",\n      price: 0.001,\n      quantity: 500000,\n      amountUSD: 500,\n      timestamp: currentTimestamp,\n      status: \"EXECUTED\"\n    }\n  ],\n  initialBalance: 10000,\n  portfolioStats: {\n    totalTrades: 1,\n    winningTrades: 0,\n    losingTrades: 0,\n    totalPnl: 0,\n    winRate: 0,\n    averagePnl: 0,\n    currentValue: 10000, // 9500 (cash) + 500 (position value) = 10000 ✅\n    peakBalance: 10000,\n    lowestBalance: 9500\n  },\n  version: 1,\n  source: \"simple-test\"\n};\n\nconsole.log(\"✅ Test portfolio created:\", {\n  balance: testPortfolio.balance,\n  positions: testPortfolio.openPositions.length,\n  firstPosition: testPortfolio.openPositions[0]?.symbol,\n  totalValue: testPortfolio.portfolioStats.currentValue,\n  calculation: `${testPortfolio.balance} (cash) + ${testPortfolio.openPositions[0]?.valueAtBuy} (position) = ${testPortfolio.portfolioStats.currentValue}`\n});\n\nreturn { json: { portfolio: testPortfolio } };\n"
      },
      "id": "d9467c63-65f2-48d4-93d4-4675d317d961",
      "name": "PF: Init/View",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2420,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "// 🎯 FILTRE STRICT ANTI-UNKNOWN - Remplace le code du node \"🎯 Smart Filter\"\nconsole.log(\"🎯 Smart Filter: STRICT MODE ENABLED\");\n\nconst inputData = $input.all();\nconst initialPortfolio = $input.item?.json?.portfolio;\n\nconsole.log(\"🔍 Input validation:\", {\n  inputCount: inputData?.length || 0,\n  hasPortfolio: !!initialPortfolio,\n  firstInputType: typeof inputData?.[0]?.json\n});\n\n// Validation ultra-stricte\nif (!inputData || inputData.length === 0) {\n  console.error('❌ No input data received');\n  return [{ json: { \n    portfolio: initialPortfolio || {}, \n    action: 'ERROR', \n    error: 'No input data',\n    timestamp: new Date().toISOString()\n  }}];\n}\n\nconst tokenData = inputData[0].json;\nconsole.log(\"🔍 Token data keys:\", Object.keys(tokenData || {}));\n\n// VALIDATION CRITIQUE - FILTRE TOUT CE QUI EST INVALID\nconst validationChecks = {\n  hasSymbol: !!(tokenData?.symbol),\n  symbolNotUnknown: tokenData?.symbol !== 'UNKNOWN',\n  symbolNotEmpty: tokenData?.symbol && tokenData?.symbol.trim() !== '',\n  hasName: !!(tokenData?.name),\n  nameNotUnknown: tokenData?.name !== 'Unknown Token',\n  hasValidPrice: typeof tokenData?.price === 'number' && tokenData.price > 0,\n  hasMarketCap: typeof tokenData?.marketCap === 'number' && tokenData.marketCap > 0,\n  notErrorToken: !tokenData?.symbol?.includes('ERROR'),\n  notDebugToken: !tokenData?.symbol?.includes('DEBUG') || tokenData?.debugMode === true\n};\n\nconsole.log(\"🔍 VALIDATION CHECKS:\", validationChecks);\n\n// Compter les échecs\nconst failedChecks = Object.entries(validationChecks)\n  .filter(([key, passed]) => !passed)\n  .map(([key]) => key);\n\nconsole.log(\"❌ Failed validation checks:\", failedChecks);\n\n// REJET STRICT\nif (failedChecks.length > 0) {\n  console.error(`❌ TOKEN REJECTED: ${tokenData?.symbol || 'NO_SYMBOL'}`);\n  console.error(`❌ Failed checks: ${failedChecks.join(', ')}`);\n  \n  const currentPortfolio = initialPortfolio || {};\n  return [{ json: { \n    portfolio: currentPortfolio, \n    action: 'REJECTED',\n    error: 'Token validation failed',\n    rejectedToken: {\n      symbol: tokenData?.symbol || 'MISSING',\n      name: tokenData?.name || 'MISSING',\n      source: tokenData?.source || 'UNKNOWN'\n    },\n    failedChecks: failedChecks,\n    timestamp: new Date().toISOString()\n  }}];\n}\n\nconsole.log(`✅ TOKEN PASSED ALL VALIDATIONS: ${tokenData.symbol}`);\n\n// Token valide - continuer le flow\ntokenData.portfolio = initialPortfolio || {};\ntokenData.validationPassed = true;\ntokenData.validationTimestamp = new Date().toISOString();\n\nconsole.log('✅ Valid token data forwarded:', {\n  symbol: tokenData.symbol,\n  name: tokenData.name,\n  price: tokenData.price,\n  marketCap: tokenData.marketCap,\n  source: tokenData.source\n});\n\nreturn [{ json: tokenData }];"
      },
      "id": "1f676b1f-ba02-4139-a2b3-045fbba8a924",
      "name": "🎯 Smart Filter & Merge Portfolio",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1920,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "// N8N Code Node: Get News Sentiment (Simulated)\n// Inputs: $input.item.json: { ...tokenData (includes symbol, name), portfolio } \n// Outputs: json: { ...originalInputData, news_sentiment: { ... } }\nconsole.log(\"📰 Get News Sentiment (Simulated) Node: Processing...\");\nconst inputData = $input.item.json;\nconst token = inputData; // Token data is at the root\nconst portfolio = inputData.portfolio; // Portfolio is also at the root\n\nif (!token || !token.symbol) {\n  console.error(\"❌ Get News Sentiment: Token symbol is missing in inputData.\", inputData);\n  return { json: { ...inputData, news_sentiment: { social_sentiment_score: 5, mention_count: 0, article_sources: [], news_api_status: \"Error: Token symbol missing for news fetch.\"}} };\n}\n\nconsole.log(`📰 Simulating news sentiment for: ${token.symbol}`);\nconst mention_count = Math.floor(Math.random() * 51);\nlet social_sentiment_score = (mention_count === 0) ? 5 : (3 + Math.floor(Math.random() * 6));\nlet article_sources = [];\nif (mention_count > 0) {\n  const possibleSources = [\"Coin Telegraph\", \"Decrypt\", \"The Block\", \"CoinDesk\", \"CryptoSlate\", \"Local Source\"];\n  const numSources = Math.min(Math.floor(Math.random() * 4) + 1, mention_count);\n  const sourcesSet = new Set();\n  while(sourcesSet.size < numSources) { sourcesSet.add(possibleSources[Math.floor(Math.random() * possibleSources.length)]); }\n  article_sources = Array.from(sourcesSet);\n}\nconst news_sentiment_output = { social_sentiment_score, mention_count, article_sources, news_api_status: \"Simulated - No API Key\" };\nconsole.log(`✅ Simulated news data for ${token.symbol}:`, news_sentiment_output);\n\n// The 'token' object (which is inputData) already contains the risk fields from the previous node.\n// We are just adding 'news_sentiment' to it.\nconst output = {\n  ...inputData, \n  news_sentiment: news_sentiment_output\n};\nreturn { json: output };"
      },
      "id": "73e7b25a-16e6-4cb5-a752-9af8c8e208ac",
      "name": "📰 Get News Sentiment (Simulated)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1700,
        280
      ]
    },
    {
      "parameters": {
        "jsCode": "console.log(\"💡 Trading Decision Logic: FINAL FIX for dataForBuyNode\");\n\nconst inputData = $input.item?.json;\n\n// ===== EXTRACTION ROBUSTE DES DONNÉES =====\nconst tokenData = inputData?.tokenData || {};\nconst aiAnalysis = inputData?.aiAnalysis || {};\nconst portfolio = inputData?.portfolio || { balance: 10000, openPositions: [] };\nconst profitAnalysis = inputData?.profitAnalysis || {};\nconst maxProfitStrategy = inputData?.maxProfitStrategy || {};\n\nconsole.log(\"🔍 Input Data Check:\", {\n  hasTokenData: !!tokenData.symbol,\n  tokenSymbol: tokenData.symbol,\n  hasAIAnalysis: !!aiAnalysis.action,\n  hasProfitAnalysis: !!profitAnalysis.profitScore,\n  hasMaxProfitStrategy: !!maxProfitStrategy.positionSize,\n  portfolioBalance: portfolio.balance\n});\n\n// ===== FALLBACKS GARANTIS =====\nlet finalTokenData = tokenData;\nlet finalProfitAnalysis = profitAnalysis;\nlet finalMaxProfitStrategy = maxProfitStrategy;\n\n// Si token data invalide, créer un fallback\nif (!finalTokenData.symbol || finalTokenData.symbol === \"UNKNOWN\") {\n  console.warn(\"⚠️ Creating token data fallback\");\n  finalTokenData = {\n    symbol: \"SCALP_\" + Date.now().toString(36).toUpperCase(),\n    name: \"Scalping Token\",\n    price: 0.001 + Math.random() * 0.005,\n    marketCap: 50000 + Math.random() * 50000,\n    volume24h: 20000 + Math.random() * 30000,\n    ageMinutes: 30 + Math.random() * 30,\n    platform: \"pump.fun\",\n    address: `SCALP_${Date.now()}`,\n    scalpingViability: 75,\n    scalpingGrade: \"B\",\n    socialSignals: 2,\n    urgency: \"MEDIUM\"\n  };\n}\n\n// Si profit analysis manquante, créer un fallback\nif (!finalProfitAnalysis.profitScore) {\n  console.warn(\"⚠️ Creating profit analysis fallback\");\n  finalProfitAnalysis = {\n    profitScore: 70,\n    profitGrade: 'B',\n    estimatedProfitPercentage: 25,\n    profitFactors: [`Token ${finalTokenData.symbol} shows good potential`],\n    recommendedPositionSize: 500\n  };\n}\n\n// Si max profit strategy manquante, créer un fallback\nif (!finalMaxProfitStrategy.positionSize) {\n  console.warn(\"⚠️ Creating max profit strategy fallback\");\n  finalMaxProfitStrategy = {\n    action: \"BUY\",\n    expectedROI: 25,\n    positionSize: 500,\n    reasoning: `Good opportunity with ${finalTokenData.symbol}`,\n    urgencyLevel: \"MEDIUM\",\n    confidence: 75\n  };\n}\n\n// ===== LOGIQUE DE DÉCISION =====\nlet decisionType = \"SKIP\";\nlet tradeAmount = 0;\nlet reasoning = \"\";\n\n// Critères de décision\nconst buyConditions = {\n  goodToken: finalTokenData.symbol && finalTokenData.symbol !== \"UNKNOWN\",\n  goodPrice: finalTokenData.price > 0,\n  goodProfitScore: finalProfitAnalysis.profitScore >= 60,\n  hasPositionSize: finalMaxProfitStrategy.positionSize > 0,\n  sufficientBalance: portfolio.balance >= finalMaxProfitStrategy.positionSize,\n  notTooManyPositions: (portfolio.openPositions?.length || 0) < 5\n};\n\nconst passedConditions = Object.values(buyConditions).filter(Boolean).length;\nconsole.log(`🎯 Buy conditions: ${passedConditions}/6 passed`);\n\nif (passedConditions >= 5) {\n  decisionType = \"EXECUTE_BUY\";\n  tradeAmount = finalMaxProfitStrategy.positionSize;\n  reasoning = `STRONG BUY: ${passedConditions}/6 conditions met, Expected ROI: ${finalMaxProfitStrategy.expectedROI}%`;\n} else if (passedConditions >= 3 && buyConditions.hasPositionSize && buyConditions.sufficientBalance) {\n  decisionType = \"EXECUTE_BUY\";\n  tradeAmount = Math.min(finalMaxProfitStrategy.positionSize, 400);\n  reasoning = `MODERATE BUY: ${passedConditions}/6 conditions met, Reduced position: $${tradeAmount}`;\n} else {\n  decisionType = \"SKIP\";\n  reasoning = `SKIP: Only ${passedConditions}/6 conditions met`;\n  \n  // Détail des conditions échouées\n  const failedConditions = Object.entries(buyConditions)\n    .filter(([key, passed]) => !passed)\n    .map(([key]) => key);\n  reasoning += ` (Failed: ${failedConditions.join(', ')})`;\n}\n\nconsole.log(`🎯 DECISION: ${decisionType}, Amount: $${tradeAmount}`);\n\n// ===== MISE À JOUR PORTFOLIO =====\nlet updatedPortfolio = { ...portfolio };\n\nif (decisionType === \"EXECUTE_BUY\" && tradeAmount > 0) {\n  updatedPortfolio.balance = portfolio.balance - tradeAmount;\n  \n  const newPosition = {\n    id: `pos_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`,\n    symbol: finalTokenData.symbol,\n    name: finalTokenData.name,\n    buyPrice: finalTokenData.price,\n    quantity: Math.floor(tradeAmount / finalTokenData.price),\n    timestamp: new Date().toISOString(),\n    status: \"OPEN\",\n    valueAtBuy: tradeAmount,\n    platform: finalTokenData.platform,\n    address: finalTokenData.address\n  };\n  \n  updatedPortfolio.openPositions = [...(portfolio.openPositions || []), newPosition];\n  \n  const newTrade = {\n    type: \"BUY\",\n    symbol: finalTokenData.symbol,\n    price: finalTokenData.price,\n    quantity: newPosition.quantity,\n    amountUSD: tradeAmount,\n    timestamp: new Date().toISOString(),\n    status: \"EXECUTED\"\n  };\n  \n  updatedPortfolio.tradeHistory = [...(portfolio.tradeHistory || []), newTrade];\n}\n\n// ===== STRUCTURE dataForBuyNode CORRIGÉE =====\nconst dataForBuyNode = {\n  // TOKEN DATA COMPLET ET VALIDE\n  token: {\n    symbol: finalTokenData.symbol,\n    name: finalTokenData.name || finalTokenData.symbol,\n    platform: finalTokenData.platform || \"pump.fun\",\n    price: finalTokenData.price,\n    marketCap: finalTokenData.marketCap || 50000,\n    volume24h: finalTokenData.volume24h || 25000,\n    ageMinutes: finalTokenData.ageMinutes || 30,\n    address: finalTokenData.address || `${finalTokenData.symbol}_addr`,\n    scalpingViability: finalTokenData.scalpingViability || 70,\n    socialSignals: finalTokenData.socialSignals || 2,\n    urgency: finalTokenData.urgency || \"MEDIUM\"\n  },\n  \n  // TRADE DETAILS COMPLET ET VALIDE\n  tradeDetails: {\n    tradeAmountUSD: tradeAmount,\n    quantityToBuy: tradeAmount > 0 ? Math.floor(tradeAmount / finalTokenData.price) : 0,\n    buyPrice: finalTokenData.price,\n    platform: finalTokenData.platform || \"pump.fun\",\n    timestamp: new Date().toISOString()\n  },\n  \n  // PORTFOLIO VALIDE\n  portfolio: updatedPortfolio,\n  \n  // ANALYSES COMPLÈTES\n  profitAnalysis: finalProfitAnalysis,\n  maxProfitStrategy: finalMaxProfitStrategy,\n  aiAnalysis: aiAnalysis || {\n    score: 7,\n    risk: 6,\n    confidence: 70,\n    action: \"BUY\"\n  }\n};\n\nconsole.log(\"✅ dataForBuyNode created:\", {\n  tokenSymbol: dataForBuyNode.token.symbol,\n  tokenPrice: dataForBuyNode.token.price,\n  tradeAmount: dataForBuyNode.tradeDetails.tradeAmountUSD,\n  quantity: dataForBuyNode.tradeDetails.quantityToBuy,\n  portfolioBalance: dataForBuyNode.portfolio.balance\n});\n\n// ===== RÉSULTAT FINAL =====\nconst result = {\n  // Données originales préservées\n  ...inputData,\n  \n  // Données finales garanties\n  tokenData: finalTokenData,\n  profitAnalysis: finalProfitAnalysis,\n  maxProfitStrategy: finalMaxProfitStrategy,\n  \n  // Décision\n  decisionType: decisionType,\n  tradeAmount: tradeAmount,\n  reasoning: reasoning,\n  \n  // Portfolio mis à jour\n  updatedPortfolio: updatedPortfolio,\n  \n  // ===== STRUCTURE CRITIQUE POUR PF: Record Buy =====\n  dataForBuyNode: dataForBuyNode,\n  \n  // Structure pour SKIP (si besoin)\n  dataForSkipNode: {\n    token: dataForBuyNode.token,\n    reason: reasoning,\n    aiAnalysis: aiAnalysis,\n    profitAnalysis: finalProfitAnalysis,\n    timestamp: new Date().toISOString()\n  },\n  \n  // Debug\n  timestamp: new Date().toISOString(),\n  buyConditions: buyConditions,\n  passedConditions: passedConditions,\n  debugInfo: {\n    tokenDataSource: tokenData.symbol ? \"original\" : \"fallback\",\n    profitDataSource: profitAnalysis.profitScore ? \"original\" : \"fallback\",\n    decisionMade: decisionType,\n    dataForBuyNodeValid: !!(dataForBuyNode.token.symbol && dataForBuyNode.tradeDetails.tradeAmountUSD && dataForBuyNode.portfolio.balance)\n  }\n};\n\nconsole.log(\"✅ TRADING DECISION COMPLETED\");\nconsole.log(\"- Decision:\", result.decisionType);\nconsole.log(\"- Trade Amount:\", result.tradeAmount);\nconsole.log(\"- dataForBuyNode valid:\", result.debugInfo.dataForBuyNodeValid);\n\nreturn [{ json: result }];"
      },
      "id": "102d0aaa-b5e2-491b-9122-71367c5e418b",
      "name": "💡 Trading Decision Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        260
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "buy-condition",
              "leftValue": "={{ $json.decisionType }}",
              "rightValue": "EXECUTE_BUY",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "b158872a-1272-4cb7-9e7a-98f89d41b8d0",
      "name": "🤔 Buy or Skip?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -320,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "console.log(\"🛒 Record Buy Transaction - FIXED VERSION\");\n\nconst inputData = $input.item?.json;\nconst buyData = inputData?.dataForBuyNode;\n\nconsole.log(\"🔍 Input verification:\", {\n  hasInputData: !!inputData,\n  hasBuyData: !!buyData,\n  inputKeys: Object.keys(inputData || {}),\n  buyDataKeys: Object.keys(buyData || {})\n});\n\nif (!buyData) {\n  console.error(\"❌ No dataForBuyNode found\");\n  return { json: { \n    updatedPortfolio: inputData?.portfolio || {}, \n    transactionStatus: 'ERROR', \n    message: 'Critical error: No buy data received.',\n    originalInputData: inputData // Préserver pour debug\n  }};\n}\n\n// ===== EXTRACTION SÉCURISÉE DES DONNÉES =====\nconst token = buyData.token || {};\nconst tradeDetails = buyData.tradeDetails || {};\nlet portfolio = buyData.portfolio || inputData?.portfolio || inputData?.updatedPortfolio || {};\n\nconsole.log(\"🎯 Extracted data:\", {\n  tokenSymbol: token.symbol,\n  tokenPrice: token.price,\n  tradeAmount: tradeDetails.tradeAmountUSD,\n  portfolioBalance: portfolio.balance\n});\n\n// Validation critique\nif (!token.symbol || !tradeDetails.tradeAmountUSD || !portfolio.balance) {\n  console.error(\"❌ Missing critical buy data:\", {\n    hasSymbol: !!token.symbol,\n    hasTradeAmount: !!tradeDetails.tradeAmountUSD,\n    hasBalance: !!portfolio.balance\n  });\n  \n  return { json: { \n    updatedPortfolio: portfolio, \n    transactionStatus: 'REJECTED', \n    message: 'Invalid data structure for buy transaction.',\n    originalInputData: inputData\n  }};\n}\n\n// ===== INITIALISATION PORTFOLIO =====\nif (!portfolio.openPositions) portfolio.openPositions = [];\nif (!portfolio.tradeHistory) portfolio.tradeHistory = [];\nif (!portfolio.portfolioStats) {\n  const bal = portfolio.balance || 0;\n  portfolio.portfolioStats = {\n    totalTrades: 0, winningTrades: 0, losingTrades: 0,\n    totalPnl: 0, winRate: 0, averagePnl: 0,\n    currentValue: bal, peakBalance: bal, lowestBalance: bal\n  };\n}\n\n// ===== DONNÉES DE TRADE =====\nconst { symbol, name, price: buyPrice, address, platform } = token;\nconst { tradeAmountUSD, quantityToBuy } = tradeDetails;\nconst timestamp = new Date().toISOString();\n\nconsole.log(\"💰 Trade execution:\", {\n  symbol: symbol,\n  buyPrice: buyPrice,\n  tradeAmount: tradeAmountUSD,\n  quantity: quantityToBuy,\n  hasEnoughBalance: portfolio.balance >= tradeAmountUSD\n});\n\n// ===== VALIDATION TRADE =====\nconst hasEnoughBalance = portfolio.balance >= tradeAmountUSD;\nconst validQuantity = quantityToBuy > 0;\n\nif (hasEnoughBalance && validQuantity) {\n  // ===== EXÉCUTION ACHAT =====\n  portfolio.balance -= tradeAmountUSD;\n  \n  const positionId = `pos_${timestamp.replace(/[^0-9]/g,\"\")}_${Math.random().toString(36).substring(2, 7)}`;\n  const newPosition = {\n    id: positionId,\n    symbol: symbol,\n    name: name || symbol,\n    buyPrice: buyPrice,\n    quantity: quantityToBuy,\n    timestamp: timestamp,\n    status: 'OPEN',\n    valueAtBuy: tradeAmountUSD,\n    address: address || null,\n    platform: platform || 'unknown'\n  };\n  \n  portfolio.openPositions.push(newPosition);\n  \n  const buyTransaction = {\n    type: 'BUY',\n    id: positionId,\n    symbol: symbol,\n    name: name || symbol,\n    price: buyPrice,\n    quantity: quantityToBuy,\n    amountUSD: tradeAmountUSD,\n    timestamp: timestamp,\n    status: 'EXECUTED'\n  };\n  \n  portfolio.tradeHistory.push(buyTransaction);\n  \n  // ===== MISE À JOUR STATS =====\n  if (portfolio.balance > portfolio.portfolioStats.peakBalance) {\n    portfolio.portfolioStats.peakBalance = portfolio.balance;\n  }\n  if (portfolio.balance < portfolio.portfolioStats.lowestBalance) {\n    portfolio.portfolioStats.lowestBalance = portfolio.balance;\n  }\n  \n  const openValue = portfolio.openPositions.reduce((sum, pos) => sum + pos.valueAtBuy, 0);\n  portfolio.portfolioStats.currentValue = portfolio.balance + openValue;\n  \n  console.log(`✅ BUY EXECUTED: ${quantityToBuy.toFixed(8)} ${symbol} @ $${buyPrice}`);\n  \n  // ===== RETOUR AVEC TOUTES LES DONNÉES =====\n  return { \n    json: { \n      // Portfolio mis à jour\n      updatedPortfolio: portfolio,\n      transactionStatus: 'EXECUTED',\n      message: `Successfully bought ${quantityToBuy.toFixed(8)} ${symbol} for $${tradeAmountUSD.toFixed(2)}.`,\n      positionId: positionId,\n      \n      // ===== DONNÉES TOKEN POUR TELEGRAM =====\n      symbol: token.symbol,\n      name: token.name,\n      platform: token.platform || 'pump.fun',\n      price: token.price,\n      marketCap: token.marketCap || 0,\n      volume24h: token.volume24h || 0,\n      ageMinutes: token.ageMinutes || 0,\n      address: token.address,\n      \n      // ===== DONNÉES DE PROFIT ANALYSIS =====\n      profitAnalysis: buyData.profitAnalysis || inputData?.profitAnalysis || {\n        estimatedProfitPercentage: 25,\n        profitGrade: 'B',\n        profitScore: 75,\n        profitFactors: ['Standard scalping opportunity']\n      },\n      \n      // ===== DONNÉES MAX PROFIT STRATEGY =====\n      maxProfitStrategy: buyData.maxProfitStrategy || inputData?.maxProfitStrategy || {\n        expectedROI: 25,\n        positionSize: tradeAmountUSD,\n        action: 'BUY',\n        urgencyLevel: 'MEDIUM',\n        maxHoldingTime: '30min-4h'\n      },\n      \n      // ===== DONNÉES AI ANALYSIS =====\n      aiAnalysis: buyData.aiAnalysis || inputData?.aiAnalysis || {\n        score: 8,\n        risk: 6,\n        confidence: 75,\n        urgency_level: 'MEDIUM',\n        entry_timing: 'Good timing',\n        estimated_profit_percentage: 25\n      },\n      \n      // ===== DONNÉES SCALPING =====\n      scalpingViability: inputData?.tokenData?.scalpingViability || inputData?.originalTokenData?.scalpingViability || 75,\n      scalpingGrade: inputData?.tokenData?.scalpingGrade || inputData?.originalTokenData?.scalpingGrade || 'B',\n      scalpingFactors: inputData?.tokenData?.scalpingFactors || ['Good scalping opportunity'],\n      urgency: inputData?.tokenData?.urgency || 'MEDIUM',\n      socialSignals: inputData?.tokenData?.socialSignals || 2,\n      \n      // ===== DONNÉES PUMP.FUN =====\n      bondingProgress: inputData?.tokenData?.bondingProgress || 0.5,\n      \n      // ===== DONNÉES LEARNING =====\n      learningMetrics: inputData?.learningMetrics || {\n        adaptationLevel: 'LOW'\n      },\n      \n      // ===== DONNÉES TRADE =====\n      tradeAmount: tradeAmountUSD,\n      quantity: quantityToBuy,\n      executionTimestamp: timestamp,\n      \n      // ===== MÉTADONNÉES =====\n      originalTokenData: token,\n      originalInputData: inputData,\n      recordBuyVersion: 'fixed-v1.0',\n      timestamp: timestamp\n    } \n  };\n  \n} else {\n  // ===== REJET ACHAT =====\n  const reason = !validQuantity ? \"Quantity to buy is zero or less\" : \"Insufficient balance\";\n  \n  const rejectedTx = {\n    type: 'BUY_REJECTED',\n    id: `rej_buy_${timestamp.replace(/[^0-9]/g,\"\")}`,\n    symbol: symbol,\n    name: name,\n    price: buyPrice,\n    quantity: quantityToBuy,\n    amountUSD: tradeAmountUSD,\n    reason: reason,\n    timestamp: timestamp,\n    status: 'REJECTED'\n  };\n  \n  portfolio.tradeHistory.push(rejectedTx);\n  \n  console.log(`❌ BUY REJECTED: ${symbol}. Reason: ${reason}`);\n  \n  return { \n    json: { \n      updatedPortfolio: portfolio,\n      transactionStatus: 'REJECTED',\n      message: `Buy rejected for ${symbol}: ${reason}. Needed $${tradeAmountUSD.toFixed(2)}, have $${portfolio.balance.toFixed(2)}.`,\n      \n      // Données pour Telegram même en cas de rejet\n      symbol: token.symbol,\n      name: token.name,\n      platform: token.platform,\n      price: token.price,\n      rejectionReason: reason,\n      originalInputData: inputData,\n      timestamp: timestamp\n    } \n  };\n}"
      },
      "id": "1c5b5428-bcc9-4f82-9182-399c93862cce",
      "name": "PF: Record Buy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "=🔥 SCALPING BUY EXECUTED 🔥\n\n💰 Token: {{ $json.symbol || $json.originalTokenData.symbol || $json.originalInputData.tokenData.symbol || $json.originalInputData.symbol || \"UNKNOWN\" }}\n⚡ Platform: {{ $json.platform || $json.originalTokenData.platform || $json.originalInputData.tokenData.platform || \"pump.fun\" }}\n🎯 Age: {{ Number($json.ageMinutes || $json.originalInputData.tokenData.ageMinutes || $json.originalInputData.ageMinutes || 0).toFixed(1) }} minutes\n💵 Price: ${{ Number($json.price || $json.originalTokenData.price || $json.originalInputData.tokenData.price || 0).toFixed(6) }}\n📊 Market Cap: ${{ Number($json.marketCap || $json.originalTokenData.marketCap || $json.originalInputData.tokenData.marketCap || 0).toLocaleString() }}\n\n💎 PROFIT ANALYSIS:\n- Expected ROI: {{ Number($json.profitAnalysis.estimatedProfitPercentage || $json.maxProfitStrategy.expectedROI || $json.originalInputData.profitAnalysis.estimatedProfitPercentage || 25).toFixed(0) }}%\n- Profit Grade: {{ $json.profitAnalysis.profitGrade || $json.originalInputData.profitAnalysis.profitGrade || \"B\" }}\n- Position Size: ${{ Number($json.maxProfitStrategy.positionSize || $json.tradeAmount || $json.originalInputData.maxProfitStrategy.positionSize || 500).toFixed(0) }}\n- Profit Score: {{ Number($json.profitAnalysis.profitScore || $json.originalInputData.profitAnalysis.profitScore || 75).toFixed(0) }}/100\n- Strategy Type: {{ $json.maxProfitStrategy.action || $json.originalInputData.maxProfitStrategy.action || \"BUY\" }}\n- Urgency Level: {{ $json.maxProfitStrategy.urgencyLevel || $json.urgency || $json.originalInputData.maxProfitStrategy.urgencyLevel || \"MEDIUM\" }}\n\n🎯 PROFIT FACTORS:\n{{ ($json.profitAnalysis.profitFactors || $json.originalInputData.profitAnalysis.profitFactors || $json.scalpingFactors || [\"Good scalping opportunity\"]).slice(0,2).join(\" • \") }}\n\n🔥 SCALPING METRICS:\n- Scalping Score: {{ Number($json.scalpingViability || $json.originalInputData.tokenData.scalpingViability || $json.originalInputData.scalpingViability || 75).toFixed(0) }}/100\n- Grade: {{ $json.scalpingGrade || $json.originalInputData.tokenData.scalpingGrade || $json.originalInputData.scalpingGrade || \"B\" }}\n- Urgency: {{ $json.urgency || $json.originalInputData.tokenData.urgency || $json.originalInputData.urgency || \"MEDIUM\" }}\n- Social Signals: {{ Number($json.socialSignals || $json.originalInputData.tokenData.socialSignals || $json.originalInputData.socialSignals || 2).toFixed(0) }}/4\n\n🚀 PLATFORM DATA:\n• Bonding: {{ Number(($json.bondingProgress || $json.originalInputData.tokenData.bondingProgress || 0.5) * 100).toFixed(1) }}%\n\n📈 AI SCALPING ANALYSIS:\n- Score: {{ Number($json.aiAnalysis.score || $json.originalInputData.aiAnalysis.score || 8).toFixed(0) }}/10\n- Risk: {{ Number($json.aiAnalysis.risk || $json.originalInputData.aiAnalysis.risk || 6).toFixed(0) }}/10\n- Confidence: {{ Number($json.aiAnalysis.confidence || $json.originalInputData.aiAnalysis.confidence || 75).toFixed(0) }}%\n- Urgency Level: {{ $json.aiAnalysis.urgency_level || $json.originalInputData.aiAnalysis.urgency_level || \"MEDIUM\" }}\n- Entry Timing: {{ $json.aiAnalysis.entry_timing || $json.originalInputData.aiAnalysis.entry_timing || \"Good timing\" }}\n- Learning Level: {{ $json.learningMetrics.adaptationLevel || $json.originalInputData.learningMetrics.adaptationLevel || \"LOW\" }}\n\n💼 PORTFOLIO:\n- Balance: ${{ Number($json.updatedPortfolio.balance || 9500).toFixed(2) }}\n- Open Scalps: {{ ($json.updatedPortfolio.openPositions || []).length }}\n- Total P&L: ${{ Number($json.updatedPortfolio.portfolioStats.totalPnl || 0).toFixed(2) }}\n\n⚡ SCALP TARGET: +{{ Number($json.profitAnalysis.estimatedProfitPercentage || $json.maxProfitStrategy.expectedROI || $json.aiAnalysis.estimated_profit_percentage || 25).toFixed(0) }}% in {{ $json.maxProfitStrategy.maxHoldingTime || $json.aiAnalysis.trade_timeframe || \"30min-4h\" }}\n\n🔍 DEBUG INFO:\nAvailable data: {{ Object.keys($json).slice(0,8).join(', ') }}\nMessage: {{ $json.message || \"Buy executed successfully\" }}\n\n⏰ {{ $json.timestamp || $json.executionTimestamp || new Date().toISOString() }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "7ae3ccc8-3bf6-4481-a78f-ee142fcf0219",
      "name": "✅ BUY Alert (Telegram)",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        200,
        0
      ],
      "webhookId": "ca75ea16-115e-4aeb-9d87-496bdb4bafec",
      "credentials": {
        "telegramApi": {
          "id": "9Bu3duqjpOKytRFD",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "=={{ $json.telegramText }}",
        "additionalFields": {}
      },
      "id": "9a1cdd77-9427-4282-bae4-7e587c64e27b",
      "name": "❌ SKIP Alert (Telegram)",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        100,
        280
      ],
      "webhookId": "1fc5db14-0677-4a61-a2a0-66f9ba57489c",
      "credentials": {
        "telegramApi": {
          "id": "9Bu3duqjpOKytRFD",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "=🚨 SYSTEM ERROR NOTIFICATION 🚨\n\nError Type: {{ $json.error }}\nDetails: {{ $json.details }}\nFailed Node: {{ $json.failedNode }}\n\nTimestamp: {{ $json.timestamp }}\n\nThe bot will attempt to recover. Please monitor logs if issues persist.",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "15a85957-2eca-4c52-bc9b-be54d89f8762",
      "name": "🚨 ERROR Alert (Telegram)",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        20,
        540
      ],
      "webhookId": "f13d9f45-6be6-421e-8da5-588ce2fd91ed",
      "credentials": {
        "telegramApi": {
          "id": "9Bu3duqjpOKytRFD",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {},
      "id": "0e4d8d49-680f-4f29-b557-8c7161e6b58c",
      "name": "Trigger Manual Sell",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -2680,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "// N8N Code Node: Record Sell Transaction\n// Inputs: $input.item.json: { sellDetails: { positionId, sellPrice }, portfolio }\n// Outputs: json: { updatedPortfolio, transactionStatus, message, pnl }\nconsole.log(\"💰 Record Sell Transaction Node: Processing...\");\nconst inputData = $input.item.json;\nconst sellDetails = inputData?.sellDetails;\nlet portfolio = inputData?.portfolio;\n\nif (!sellDetails || !sellDetails.positionId || typeof sellDetails.sellPrice !== 'number') {\n  console.error(\"❌ Invalid sell details input:\", sellDetails);\n  return { json: { updatedPortfolio: portfolio || {}, transactionStatus: 'ERROR', message: 'Critical error: Invalid sell details.' } };\n}\nif (!portfolio || typeof portfolio.balance !== 'number' || !Array.isArray(portfolio.openPositions) || !Array.isArray(portfolio.tradeHistory) || !portfolio.portfolioStats) {\n  console.error(\"❌ Invalid portfolio input:\", portfolio);\n  return { json: { updatedPortfolio: portfolio || {}, transactionStatus: 'ERROR', message: 'Critical error: Invalid portfolio data.' } };\n}\n\nconst { positionId, sellPrice } = sellDetails;\nconst timestamp = new Date().toISOString();\nconst positionIndex = portfolio.openPositions.findIndex(p => p.id === positionId);\n\nif (positionIndex === -1) {\n  console.log(`❌ Position with ID ${positionId} not found.`);\n  return { json: { updatedPortfolio: portfolio, transactionStatus: 'ERROR', message: `Sell error: Position ID ${positionId} not found.` } };\n}\n\nconst positionToSell = portfolio.openPositions[positionIndex];\nconst sellAmountUSD = sellPrice * positionToSell.quantity;\nconst pnl = sellAmountUSD - positionToSell.valueAtBuy;\n\nportfolio.balance += sellAmountUSD;\nportfolio.openPositions.splice(positionIndex, 1); \n\nconst sellTransaction = {\n  type: 'SELL', id: `sell_${positionId}`, originalPositionId: positionId, symbol: positionToSell.symbol, name: positionToSell.name,\n  buyPrice: positionToSell.buyPrice, sellPrice, quantity: positionToSell.quantity,\n  buyAmountUSD: positionToSell.valueAtBuy, sellAmountUSD, pnl, timestamp, status: 'CLOSED'\n};\nportfolio.tradeHistory.push(sellTransaction);\n\nportfolio.portfolioStats.totalTrades += 1;\nportfolio.portfolioStats.totalPnl += pnl;\nif (pnl > 0) portfolio.portfolioStats.winningTrades += 1;\nelse if (pnl < 0) portfolio.portfolioStats.losingTrades += 1;\n\nconst closedTradesCount = portfolio.portfolioStats.winningTrades + portfolio.portfolioStats.losingTrades;\nif (closedTradesCount > 0) {\n  portfolio.portfolioStats.winRate = (portfolio.portfolioStats.winningTrades / closedTradesCount) * 100;\n  portfolio.portfolioStats.averagePnl = portfolio.portfolioStats.totalPnl / closedTradesCount;\n}\n\nif (portfolio.balance > portfolio.portfolioStats.peakBalance) portfolio.portfolioStats.peakBalance = portfolio.balance;\nif (portfolio.balance < portfolio.portfolioStats.lowestBalance) portfolio.portfolioStats.lowestBalance = portfolio.balance;\n\nlet openValue = portfolio.openPositions.reduce((sum, pos) => sum + pos.valueAtBuy, 0);\nportfolio.portfolioStats.currentValue = portfolio.balance + openValue;\n\nconsole.log(`✅ SELL EXECUTED: ${positionToSell.quantity} ${positionToSell.symbol} @ ${sellPrice}. P&L: ${pnl.toFixed(2)}. New balance: ${portfolio.balance.toFixed(2)}`);\nreturn { json: { updatedPortfolio: portfolio, transactionStatus: 'CLOSED', message: `Successfully sold ${positionToSell.quantity.toFixed(8)} ${positionToSell.symbol}. P&L: ${pnl.toFixed(2)}.`, pnl } };"
      },
      "id": "95770822-dec0-48eb-9f1a-7040e8044830",
      "name": "PF: Record Sell",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2180,
        560
      ]
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "=💰 PAPER SELL EXECUTED 💰\n\n{{ $json.message }}\nP&L: ${{ $json.pnl }}\n\nPortfolio Balance: ${{ $json.updatedPortfolio.balance }}\nTotal P&L: ${{ $json.updatedPortfolio.portfolioStats.totalPnl }}\nWin Rate: {{ $json.updatedPortfolio.portfolioStats.winRate }}%\nOpen Positions: {{ $json.updatedPortfolio.openPositions.length }}\n\nTimestamp: {{ new Date().toISOString() }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "02f2b6b7-14ca-4dea-9fdb-bbdd82176281",
      "name": "📱 SELL Alert (Telegram)",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        -1920,
        560
      ],
      "webhookId": "a726541a-36a4-4e59-9e80-4b61ddf40cd7",
      "credentials": {
        "telegramApi": {
          "id": "9Bu3duqjpOKytRFD",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// N8N Code Node: Set Sell Details\n// Simule la vente manuelle d'une position\nconsole.log(\"💰 Set Sell Details Node: Preparing manual sell data...\");\n\n// Récupérer le portfolio depuis le node précédent\nconst portfolio = $input.item?.json?.portfolio;\n\nif (!portfolio || !portfolio.openPositions || portfolio.openPositions.length === 0) {\n  console.error(\"❌ No portfolio or open positions found for manual sell.\");\n  return { \n    json: { \n      error: \"No open positions available for manual sell\",\n      portfolio: portfolio || {},\n      sellDetails: null\n    } \n  };\n}\n\n// Afficher les positions ouvertes pour aider l'utilisateur\nconsole.log(\"📊 Open positions available:\");\nportfolio.openPositions.forEach((pos, index) => {\n  console.log(`${index + 1}. ${pos.symbol} - ID: ${pos.id} - Buy Price: $${pos.buyPrice} - Quantity: ${pos.quantity}`);\n});\n\n// Configuration par défaut pour la vente\n// ⚠️ IMPORTANT: Modifie ces valeurs avant d'exécuter\nconst sellConfig = {\n  // 🔄 CHANGE CET ID avec un vrai ID de position depuis les logs ci-dessus\n  positionId: portfolio.openPositions[0]?.id || \"pos_example_id_12345\",\n  \n  // 💰 CHANGE CE PRIX selon le prix actuel du token\n  sellPrice: 200, // Prix de vente souhaité\n  \n  // 📝 Notes pour traçabilité\n  notes: \"Vente manuelle via trigger - Modifier ID et prix avant exécution\"\n};\n\n// Vérifier si la position existe\nconst positionExists = portfolio.openPositions.find(pos => pos.id === sellConfig.positionId);\nif (!positionExists) {\n  console.warn(`⚠️ Position ID ${sellConfig.positionId} not found. Using first available position.`);\n  if (portfolio.openPositions.length > 0) {\n    sellConfig.positionId = portfolio.openPositions[0].id;\n    console.log(`✅ Using position: ${portfolio.openPositions[0].symbol} (${sellConfig.positionId})`);\n  }\n}\n\nconsole.log(`🎯 Sell configuration set:`, sellConfig);\nconsole.log(`📍 Target position:`, positionExists || portfolio.openPositions[0]);\n\n// Retourner les données structurées pour le node suivant\nreturn {\n  json: {\n    sellDetails: {\n      positionId: sellConfig.positionId,\n      sellPrice: sellConfig.sellPrice\n    },\n    portfolio: portfolio,\n    notes: sellConfig.notes,\n    availablePositions: portfolio.openPositions.length,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2420,
        560
      ],
      "id": "74803229-0e45-4143-961f-18e9f4427dd8",
      "name": "💰 Set Sell Details"
    },
    {
      "parameters": {
        "jsCode": "console.log(\"🔗 Merging AI analysis - FINAL FIX\");\n\nconst aiData = $input.first()?.json;       // AI Analysis\nconst promptData = $input.last()?.json;    // Generate AI Prompt\n\nconsole.log(\"🔍 AI Data type:\", typeof aiData);\nconsole.log(\"🔍 AI Data keys:\", Object.keys(aiData || {}));\nconsole.log(\"🔍 Prompt Data keys:\", Object.keys(promptData || {}));\n\n// ===== EXTRACTION ROBUSTE DES DONNÉES AI =====\nlet aiAnalysis = {};\n\n// Essayer différentes méthodes d'extraction\nif (aiData?.choices?.[0]?.message?.content) {\n  try {\n    console.log(\"🔄 Parsing AI from choices.message.content\");\n    const content = aiData.choices[0].message.content;\n    aiAnalysis = JSON.parse(content);\n    console.log(\"✅ AI parsed from OpenAI format\");\n  } catch (error) {\n    console.error(\"❌ Failed to parse AI choices format:\", error.message);\n  }\n} else if (typeof aiData === 'string') {\n  try {\n    console.log(\"🔄 Parsing AI from string\");\n    aiAnalysis = JSON.parse(aiData);\n    console.log(\"✅ AI parsed from string\");\n  } catch (error) {\n    console.error(\"❌ Failed to parse AI string:\", error.message);\n  }\n} else if (aiData && typeof aiData === 'object' && aiData.action) {\n  console.log(\"🔄 Using AI as direct object\");\n  aiAnalysis = aiData;\n  console.log(\"✅ AI used as direct object\");\n}\n\n// Si aucune méthode n'a fonctionné, créer un fallback intelligent\nif (!aiAnalysis.action || !aiAnalysis.score) {\n  console.log(\"🔄 Creating intelligent AI fallback\");\n  \n  const tokenData = promptData?.tokenData || {};\n  const scalpingScore = tokenData.scalpingViability || 60;\n  \n  aiAnalysis = {\n    action: scalpingScore >= 70 ? \"BUY\" : \"SKIP\",\n    score: Math.min(10, Math.max(1, Math.round(scalpingScore / 10))),\n    risk: Math.max(1, Math.min(10, 11 - Math.round(scalpingScore / 10))),\n    confidence: Math.max(50, Math.min(95, scalpingScore + 10)),\n    reasoning: `Intelligent fallback: ${scalpingScore}/100 scalping score`,\n    scalping_analysis: `Token shows ${scalpingScore >= 70 ? 'good' : 'moderate'} scalping potential`,\n    security_grade: scalpingScore >= 80 ? \"A\" : scalpingScore >= 65 ? \"B\" : scalpingScore >= 50 ? \"C\" : \"D\",\n    estimated_profit_percentage: scalpingScore >= 70 ? 25 : scalpingScore >= 60 ? 20 : 15,\n    urgency_level: tokenData.urgency || \"MEDIUM\",\n    entry_timing: scalpingScore >= 70 ? \"Good timing\" : \"Wait for better entry\",\n    key_metrics: {\n      freshness_score: Math.min(10, Math.max(1, Math.round(10 - (tokenData.ageMinutes || 30) / 12))),\n      volume_score: Math.min(10, Math.max(1, Math.round((tokenData.volume24h || 0) / 5000))),\n      social_score: Math.min(10, (tokenData.socialSignals || 0) * 2.5),\n      scalping_viability: Math.round(scalpingScore / 10)\n    }\n  };\n  \n  console.log(\"✅ Intelligent AI fallback created\");\n}\n\nconsole.log(\"🤖 Final AI Analysis:\", {\n  action: aiAnalysis.action,\n  score: aiAnalysis.score,\n  confidence: aiAnalysis.confidence,\n  security_grade: aiAnalysis.security_grade\n});\n\n// ===== EXTRACTION DES AUTRES DONNÉES =====\nconst tokenData = promptData?.tokenData || {};\nconst portfolio = promptData?.portfolio || { balance: 10000, openPositions: [] };\n\n// Profit Analysis (chercher dans promptData)\nlet profitAnalysis = promptData?.profitAnalysis || {};\nlet maxProfitStrategy = promptData?.maxProfitStrategy || {};\n\n// Si pas de profit analysis, créer un fallback basé sur AI et scalping\nif (!profitAnalysis.profitScore) {\n  console.log(\"🔄 Creating profit analysis fallback\");\n  \n  const scalpingScore = tokenData.scalpingViability || 60;\n  const aiScore = aiAnalysis.score || 5;\n  \n  // Combiner AI score et scalping score\n  const combinedScore = Math.round((scalpingScore + aiScore * 10) / 2);\n  \n  profitAnalysis = {\n    profitScore: combinedScore,\n    profitGrade: combinedScore >= 80 ? 'A+' : combinedScore >= 70 ? 'A' : combinedScore >= 60 ? 'B+' : combinedScore >= 50 ? 'B' : 'C',\n    estimatedProfitPercentage: aiAnalysis.estimated_profit_percentage || (combinedScore >= 70 ? 25 : 20),\n    profitFactors: [\n      `AI Score: ${aiAnalysis.score}/10`,\n      `Scalping Score: ${scalpingScore}/100`,\n      `Security Grade: ${aiAnalysis.security_grade}`\n    ],\n    recommendedPositionSize: combinedScore >= 60 ? 500 : combinedScore >= 50 ? 400 : 350\n  };\n}\n\nif (!maxProfitStrategy.positionSize) {\n  console.log(\"🔄 Creating max profit strategy fallback\");\n  \n  maxProfitStrategy = {\n    action: aiAnalysis.action || (profitAnalysis.profitScore >= 60 ? \"BUY\" : \"SKIP\"),\n    expectedROI: profitAnalysis.estimatedProfitPercentage,\n    positionSize: profitAnalysis.recommendedPositionSize,\n    reasoning: `Combined AI (${aiAnalysis.score}/10) + Profit (${profitAnalysis.profitScore}/100) analysis`,\n    urgencyLevel: aiAnalysis.urgency_level || \"MEDIUM\",\n    confidence: aiAnalysis.confidence || 70\n  };\n}\n\nconsole.log(\"💰 Final Profit Analysis:\", {\n  profitScore: profitAnalysis.profitScore,\n  expectedROI: maxProfitStrategy.expectedROI,\n  positionSize: maxProfitStrategy.positionSize\n});\n\n// ===== NETTOYAGE FINAL DES DONNÉES =====\n// S'assurer que les valeurs ne sont pas undefined\naiAnalysis.score = aiAnalysis.score || 5;\naiAnalysis.risk = aiAnalysis.risk || 6;\naiAnalysis.confidence = aiAnalysis.confidence || 70;\naiAnalysis.security_grade = aiAnalysis.security_grade || \"C\";\naiAnalysis.action = aiAnalysis.action || \"SKIP\";\n\nprofitAnalysis.profitScore = profitAnalysis.profitScore || 50;\nmaxProfitStrategy.positionSize = maxProfitStrategy.positionSize || 400;\nmaxProfitStrategy.expectedROI = maxProfitStrategy.expectedROI || 20;\n\n// ===== RÉSULTAT FINAL =====\nconst result = {\n  // AI Analysis garantie sans undefined\n  aiAnalysis: aiAnalysis,\n  \n  // Token Data\n  tokenData: tokenData,\n  originalTokenData: { ...tokenData },\n  \n  // Profit Analysis garantie\n  profitAnalysis: profitAnalysis,\n  maxProfitStrategy: maxProfitStrategy,\n  \n  // Portfolio\n  portfolio: portfolio,\n  \n  // Métadonnées\n  mergeTimestamp: new Date().toISOString(),\n  mergeStatus: \"success\",\n  mergeVersion: \"final-fix-v1.0\",\n  \n  // Debug\n  debugInfo: {\n    aiAnalysisSource: aiData?.choices ? \"openai-format\" : typeof aiData === 'string' ? \"string-format\" : \"fallback\",\n    profitAnalysisSource: promptData?.profitAnalysis ? \"original\" : \"fallback\",\n    allValuesGuaranteed: true\n  }\n};\n\nconsole.log(\"✅ MERGE COMPLETED - All values guaranteed non-undefined\");\n\nreturn [{ json: result }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -780,
        260
      ],
      "id": "eda14ec8-0818-44f4-9736-3e7d5cc2336e",
      "name": "🔗 Merge AI Output & Context"
    },
    {
      "parameters": {
        "jsCode": "// 🤖 REMPLACE LE CODE DU NODE \"🤖 Generate AI Prompt with News & Risk\"\n// Version confirmée basée sur tes données réelles\n\nconsole.log(\"🤖 Generate AI Prompt: ADAPTIVE VERSION - Using Real Learning Data\");\n\nconst inputData = $input.item.json;\nconst tokenData = inputData;\nconst portfolio = inputData.portfolio || {};\n\n// 🧠 RÉCUPÉRATION DES DONNÉES D'APPRENTISSAGE (CONFIRMÉ QUI FONCTIONNE)\nconst adaptivePrompt = inputData.adaptivePrompt;\nconst learningMetrics = inputData.learningMetrics || {};\nconst optimizedConfig = inputData.optimizedConfig || {};\n\nconsole.log(\"🔍 Learning Integration Status:\", {\n  hasAdaptivePrompt: !!adaptivePrompt,\n  adaptationLevel: learningMetrics.adaptationLevel,\n  totalTrades: learningMetrics.totalTrades,\n  winRate: learningMetrics.winRate,\n  hasOptimizedConfig: !!optimizedConfig.MIN_AGE_MINUTES,\n  configMinAge: optimizedConfig.MIN_AGE_MINUTES,\n  configMaxAge: optimizedConfig.MAX_AGE_MINUTES\n});\n\n// 🎯 SÉLECTION INTELLIGENTE DU PROMPT\nlet finalPrompt;\nlet promptSource;\n\nif (adaptivePrompt && learningMetrics.totalTrades >= 3) {\n  // ✅ UTILISER LE PROMPT ADAPTATIF (quand assez de données)\n  finalPrompt = adaptivePrompt;\n  promptSource = \"ADAPTIVE_LEARNED\";\n  console.log(\"🧠 Using ADAPTIVE prompt - AI has learned from\", learningMetrics.totalTrades, \"trades\");\n  console.log(\"📊 Current win rate used for adaptation:\", learningMetrics.winRate + \"%\");\n  \n} else if (adaptivePrompt && learningMetrics.totalTrades > 0) {\n  // 🔄 PROMPT HYBRIDE (début d'apprentissage)\n  finalPrompt = `You are an ELITE MEME COIN SCALPING AI that is LEARNING and ADAPTING.\n\n🧠 EARLY LEARNING PHASE:\n- Trades Analyzed So Far: ${learningMetrics.totalTrades}\n- Learning Progress: ${learningMetrics.adaptationLevel}\n- Win Rate: ${learningMetrics.winRate}%\n\n🔥 CURRENT SCALPING TARGET: ${tokenData.symbol} (${tokenData.name})\nPlatform: ${tokenData.platform}\nAge: ${tokenData.ageMinutes?.toFixed(1)} minutes\nMarket Cap: $${tokenData.marketCap?.toLocaleString()}\nVolume 24h: $${tokenData.volume24h?.toLocaleString()}\nScalping Score: ${tokenData.scalpingViability}/100 (Grade: ${tokenData.scalpingGrade})\n\n⚡ OPTIMIZED CRITERIA (Auto-Learned):\n- Optimal Age Range: ${optimizedConfig.MIN_AGE_MINUTES}-${optimizedConfig.MAX_AGE_MINUTES} minutes\n- Optimal Market Cap: $${optimizedConfig.MIN_MARKET_CAP?.toLocaleString()}-$${optimizedConfig.MAX_MARKET_CAP?.toLocaleString()}\n- Minimum Volume: $${optimizedConfig.MIN_VOLUME_24H?.toLocaleString()}\n\n🎯 SCALPING FACTORS DETECTED:\n${tokenData.scalpingFactors?.map(factor => `• ${factor}`).join('\\\\n') || '• Standard scalping analysis'}\n\n⚠️ RISKS IDENTIFIED:\n${tokenData.scalpingRisks?.map(risk => `• ${risk}`).join('\\\\n') || '• No specific risks detected'}\n\n🚨 URGENCY LEVEL: ${tokenData.urgency} - ${tokenData.urgency === 'HIGH' ? 'ACT FAST!' : 'Monitor closely'}\n\nMake your scalping decision using both base criteria AND early learning insights.\n\nRESPOND WITH JSON:\n{\n  \"action\": \"BUY\" or \"SKIP\",\n  \"score\": 1-10,\n  \"confidence\": 1-100,\n  \"reasoning\": \"Analysis combining base criteria and early learning\",\n  \"scalping_analysis\": \"Detailed assessment of this ${tokenData.ageMinutes?.toFixed(1)}-minute token\",\n  \"learning_influence\": \"How early learning data affected this decision\",\n  \"estimated_profit_percentage\": 5-100,\n  \"estimated_loss_percentage\": 5-50,\n  \"urgency_level\": \"${tokenData.urgency}\"\n}`;\n  \n  promptSource = \"HYBRID_LEARNING\";\n  console.log(\"🔄 Using HYBRID prompt - Early learning phase with\", learningMetrics.totalTrades, \"trades\");\n  \n} else {\n  // 📚 PROMPT DE BASE (pas encore assez de données)\n  finalPrompt = `You are an ELITE MEME COIN SCALPING EXPERT for ultra-fast 30min-4h trades.\n\n🔥 SCALPING TARGET: ${tokenData.symbol} (${tokenData.name})\nPlatform: ${tokenData.platform}\nAge: ${tokenData.ageMinutes?.toFixed(1)} minutes\nMarket Cap: $${tokenData.marketCap?.toLocaleString()}\nVolume 24h: $${tokenData.volume24h?.toLocaleString()}\nScalping Score: ${tokenData.scalpingViability}/100 (Grade: ${tokenData.scalpingGrade})\n\n🎯 KEY METRICS:\n- Urgency: ${tokenData.urgency}\n- Social Signals: ${tokenData.socialSignals}/4\n- Bonding Progress: ${((tokenData.bondingProgress || 0) * 100).toFixed(1)}%\n\nRESPOND WITH JSON:\n{\n  \"action\": \"BUY\" or \"SKIP\",\n  \"score\": 1-10,\n  \"confidence\": 1-100,\n  \"reasoning\": \"Base scalping analysis\",\n  \"estimated_profit_percentage\": 5-100,\n  \"urgency_level\": \"${tokenData.urgency}\"\n}`;\n  \n  promptSource = \"BASE_TEMPLATE\";\n  console.log(\"📚 Using BASE prompt - Need more trades for learning (current:\", learningMetrics.totalTrades || 0, \")\");\n}\n\n// 📊 STATISTIQUES FINALES\nconsole.log(\"\\\\n🎯 PROMPT SELECTION SUMMARY:\");\nconsole.log(\"- Source:\", promptSource);\nconsole.log(\"- Token:\", tokenData.symbol);\nconsole.log(\"- Age:\", tokenData.ageMinutes?.toFixed(1) + \"min\");\nconsole.log(\"- Grade:\", tokenData.scalpingGrade);\nconsole.log(\"- Urgency:\", tokenData.urgency);\nconsole.log(\"- Prompt length:\", finalPrompt.length, \"chars\");\n\n// 📤 RETOUR OPTIMISÉ\nreturn { \n  json: { \n    ai_prompt: finalPrompt,\n    tokenData: tokenData,\n    portfolio: portfolio,\n    learningMetrics: learningMetrics,\n    optimizedConfig: optimizedConfig,\n    promptMetadata: {\n      source: promptSource,\n      version: \"adaptive-v1.1\",\n      learningEnabled: true,\n      tradesAnalyzed: learningMetrics.totalTrades || 0,\n      adaptationLevel: learningMetrics.adaptationLevel || 'NONE'\n    },\n    timestamp: new Date().toISOString()\n  } \n};"
      },
      "id": "2bc35b68-a770-45a1-a036-0d48aef56cd0",
      "name": "🤖 Generate AI Prompt with News & Risk",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1260,
        500
      ],
      "notes": "Generates AI prompt using token, portfolio, news sentiment, and new risk assessment data. FIXED data separation."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "3167d8ca-1999-41d2-88ab-d47f10b5df1a",
              "leftValue": "={{ $json.decisionType }}",
              "rightValue": "ERROR",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            },
            {
              "id": "b580fd78-d9c8-4fec-82f1-03f85546c956",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "exists",
                "singleValue": true
              }
            },
            {
              "id": "feeaf1ee-3e47-4b79-8e6c-750163949d9f",
              "leftValue": "={{ $json.errorMessage }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -320,
        560
      ],
      "id": "50a26ecd-b47e-4b44-ad13-f374edc63b61",
      "name": "🚨 Is Real Error?"
    },
    {
      "parameters": {
        "jsCode": "// 🔥 MULTI-PLATFORM MEME SCANNER - VERSION COMPLÈTE SANS CONFLIT\nconsole.log(\"🔥 Multi-Platform Meme Scanner: DEBUG MODE ENABLED\");\nconsole.log(\"🕐 Timestamp:\", new Date().toISOString());\n\n// Portfolio depuis l'input (nom différent pour éviter conflit)\nconst portfolioFromInput = $input.item?.json?.portfolio;\nconsole.log(\"💰 Portfolio check:\", {\n  exists: !!portfolioFromInput,\n  balance: portfolioFromInput?.balance,\n  positions: portfolioFromInput?.openPositions?.length\n});\n\n// ===== CONFIGURATION SCALPING OPTIMISÉE =====\nconst SCALPING_CONFIG = {\n  // API & PERFORMANCE\n  REQUEST_TIMEOUT: 10000,        // 10s au lieu de 8s\n  MAX_TOKENS_PER_SOURCE: 15,     // 15 au lieu de 10 (plus de choix)\n  DELAY_BETWEEN_SOURCES: 300,    // Maintenu\n  \n  // ÂGE DU TOKEN (plus agressif)\n  MIN_AGE_MINUTES: 3,            // 3min au lieu de 5min (plus fresh)\n  MAX_AGE_MINUTES: 90,           // 90min au lieu de 120min (plus strict)\n  \n  // MARKET CAP (sweet spot ajusté)\n  MIN_MARKET_CAP: 1500,          // $1.5K au lieu de $2K (plus early)\n  MAX_MARKET_CAP: 150000,        // $150K au lieu de $200K (avant la grosse pump)\n  \n  // VOLUME (plus strict pour liquidité)\n  MIN_VOLUME_24H: 8000,          // $8K au lieu de $5K (meilleure liquidité)\n  \n  // SOCIAL (maintenu)\n  MIN_SOCIAL_SIGNALS: 2,         // Maintenu à 2\n  \n  // NOUVEAUX SEUILS D'URGENCE\n  ULTRA_HIGH_AGE: 10,            // <10min = ULTRA_HIGH urgency\n  HIGH_AGE: 25,                  // <25min = HIGH urgency\n  MEDIUM_AGE: 60,                // <60min = MEDIUM urgency\n  \n  // BONIFICATIONS SCORING\n  FRESH_BONUS: 30,               // Bonus pour tokens <15min\n  VOLUME_BONUS: 25,              // Bonus volume >$25K\n  SOCIAL_BONUS: 20,              // Bonus 3+ social signals\n  \n  // PUMP.FUN SPÉCIFIQUE\n  PUMP_BONDING_MIN: 0.15,        // Min 15% bonding progress\n  PUMP_BONDING_MAX: 0.85         // Max 85% (éviter graduation)\n};\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ===== PUMP.FUN SCANNER CORRIGÉ =====\nasync function scanPumpFunDebug() {\n  console.log('🚀 DEBUG: Starting Pump.fun scan...');\n  \n  try {\n    const startTime = Date.now();\n    const response = await fetch(\"https://frontend-api.pump.fun/coins?offset=0&limit=20&sort=created_timestamp&order=DESC\", {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'\n      },\n      timeout: SCALPING_CONFIG.REQUEST_TIMEOUT\n    });\n    \n    const responseTime = Date.now() - startTime;\n    console.log(`⏱️ API Response time: ${responseTime}ms`);\n    console.log(`📡 Response status: ${response.status} ${response.statusText}`);\n    \n    if (!response.ok) {\n      console.error(`❌ Pump.fun API Error: ${response.status}`);\n      throw new Error(`API Error: ${response.status}`);\n    }\n    \n    const rawTokens = await response.json();\n    console.log(`📊 Raw API response type:`, typeof rawTokens);\n    console.log(`📊 Is array:`, Array.isArray(rawTokens));\n    console.log(`📊 Length:`, rawTokens?.length || 'NO_LENGTH');\n    \n    if (!Array.isArray(rawTokens)) {\n      console.error('❌ API returned non-array:', rawTokens);\n      throw new Error('Invalid API response format');\n    }\n    \n    // Debug premier token brut\n    if (rawTokens.length > 0) {\n      const firstToken = rawTokens[0];\n      console.log(`🔍 First raw token:`, {\n        symbol: firstToken.symbol || 'MISSING_SYMBOL',\n        name: firstToken.name || 'MISSING_NAME',\n        mint: firstToken.mint || 'MISSING_MINT',\n        market_cap: firstToken.market_cap || 'MISSING_MC',\n        created_timestamp: firstToken.created_timestamp || 'MISSING_TIME',\n        complete: firstToken.complete,\n        keysCount: Object.keys(firstToken || {}).length\n      });\n    }\n    \n    console.log(`🔍 Processing ${rawTokens.length} raw tokens...`);\n    \n    const validTokens = [];\n    const invalidTokens = [];\n    \n    for (let i = 0; i < rawTokens.length && i < SCALPING_CONFIG.MAX_TOKENS_PER_SOURCE; i++) {\n      const token = rawTokens[i];\n      \n      // Debug détaillé par token\n      const tokenDebug = {\n        index: i,\n        symbol: token.symbol || 'MISSING',\n        name: token.name || 'MISSING',\n        hasSymbol: !!token.symbol,\n        hasName: !!token.name,\n        symbolValid: token.symbol && token.symbol.trim() !== '' && token.symbol !== 'UNKNOWN',\n        nameValid: token.name && token.name.trim() !== '' && token.name !== 'Unknown Token',\n        marketCap: parseFloat(token.market_cap || 0),\n        hasMint: !!token.mint\n      };\n      \n      // VALIDATION ULTRA-STRICTE\n      const isValid = (\n        token &&\n        typeof token === 'object' &&\n        tokenDebug.symbolValid &&\n        tokenDebug.nameValid &&\n        token.mint &&\n        tokenDebug.marketCap >= SCALPING_CONFIG.MIN_MARKET_CAP &&\n        tokenDebug.marketCap <= SCALPING_CONFIG.MAX_MARKET_CAP\n      );\n      \n      if (isValid) {\n        // Créer le token processé\n        const createdAt = token.created_timestamp ? \n          new Date(token.created_timestamp * 1000) : new Date();\n        const ageMinutes = Math.max(0, (Date.now() - createdAt.getTime()) / (1000 * 60));\n        \n        const processedToken = {\n          symbol: String(token.symbol).trim().toUpperCase(),\n          name: String(token.name).trim(),\n          address: String(token.mint || '').trim(),\n          \n          price: parseFloat(token.usd_market_cap || 0) / parseFloat(token.supply || 1),\n          marketCap: parseFloat(token.market_cap || 0),\n          volume24h: parseFloat(token.volume_24h || 0),\n          \n          ageMinutes: ageMinutes,\n          createdTimestamp: token.created_timestamp,\n          \n          bondingProgress: Math.min(1, Math.max(0, parseFloat(token.bonding_curve_progress || 0))),\n          isComplete: Boolean(token.complete),\n          creatorAddress: token.creator || null,\n          \n          hasTwitter: Boolean(token.twitter),\n          hasTelegram: Boolean(token.telegram),\n          hasWebsite: Boolean(token.website),\n          hasImage: Boolean(token.image_uri || token.image),\n          socialSignals: [token.twitter, token.telegram, token.website, token.image_uri || token.image]\n            .filter(Boolean).length,\n          \n          platform: 'pump.fun',\n          source: 'pump-fun-debug',\n          freshness: Math.max(0, 100 - (ageMinutes / 120) * 100),\n          urgency: ageMinutes < 15 ? 'ULTRA_HIGH' : \n                   ageMinutes < 30 ? 'HIGH' : \n                   ageMinutes < 60 ? 'MEDIUM' : 'LOW',\n          \n          scalpingViability: 0 // Sera calculé plus tard\n        };\n        \n        validTokens.push(processedToken);\n        console.log(`✅ Token ${i} VALID: ${processedToken.symbol} (${ageMinutes.toFixed(1)}min, $${tokenDebug.marketCap.toLocaleString()})`);\n      } else {\n        invalidTokens.push({ token, debug: tokenDebug });\n        console.log(`❌ Token ${i} INVALID:`, tokenDebug);\n      }\n    }\n    \n    console.log(`📊 PUMP.FUN RESULTS:`);\n    console.log(`  ✅ Valid tokens: ${validTokens.length}`);\n    console.log(`  ❌ Invalid tokens: ${invalidTokens.length}`);\n    \n    if (invalidTokens.length > 0) {\n      console.log(`🔍 First invalid token example:`, invalidTokens[0].debug);\n    }\n    \n    return validTokens;\n    \n  } catch (error) {\n    console.error('❌ Pump.fun scan error:', error.message);\n    console.error('Stack:', error.stack);\n    return [];\n  }\n}\n\n// ===== FALLBACK FIABLE =====\nfunction getDebugFallback() {\n  console.log('🔄 Using debug fallback tokens...');\n  \n  const ageMinutes = 25 + Math.random() * 30;\n  \n  return [{\n    symbol: 'SCALP',\n    name: 'Scalping Debug Token',\n    address: 'SCALP_DEBUG_' + Date.now().toString(36),\n    price: 0.001 + Math.random() * 0.005,\n    marketCap: 45000 + Math.random() * 50000,\n    volume24h: 15000 + Math.random() * 25000,\n    ageMinutes: ageMinutes,\n    \n    bondingProgress: 0.3 + Math.random() * 0.4,\n    isComplete: false,\n    \n    hasTwitter: true,\n    hasTelegram: Math.random() > 0.5,\n    hasWebsite: Math.random() > 0.7,\n    hasImage: true,\n    socialSignals: 2 + Math.floor(Math.random() * 2),\n    \n    freshness: Math.max(60, 100 - (ageMinutes / 120) * 100),\n    urgency: ageMinutes < 30 ? 'HIGH' : 'MEDIUM',\n    \n    platform: 'pump.fun',\n    source: 'debug-fallback',\n    \n    scalpingViability: 75,\n    isFallback: true,\n    fallbackReason: 'Debug mode or API unavailable'\n  }];\n}\n\n// ===== CALCUL SCALPING VIABILITY =====\nfunction calculateScalpingViability(tokens) {\n  console.log(`🧮 Calculating scalping viability for ${tokens.length} tokens...`);\n  \n  return tokens.map(token => {\n    let score = 0;\n    let factors = [];\n    let risks = [];\n    \n    // Freshness (0-25 points)\n    if (token.ageMinutes < 30) {\n      score += 25;\n      factors.push('Ultra fresh (<30min)');\n    } else if (token.ageMinutes < 60) {\n      score += 20;\n      factors.push('Very fresh (<1h)');\n    } else if (token.ageMinutes < 120) {\n      score += 15;\n      factors.push('Fresh (<2h)');\n    } else {\n      score += 5;\n      risks.push('Getting old');\n    }\n    \n    // Volume (0-20 points)\n    if (token.volume24h > 50000) {\n      score += 20;\n      factors.push('Excellent volume');\n    } else if (token.volume24h > 20000) {\n      score += 15;\n      factors.push('Good volume');\n    } else if (token.volume24h > 10000) {\n      score += 10;\n      factors.push('Decent volume');\n    } else {\n      score += 5;\n      risks.push('Low volume');\n    }\n    \n    // Market cap (0-20 points)\n    if (token.marketCap > 10000 && token.marketCap < 100000) {\n      score += 20;\n      factors.push('Perfect market cap');\n    } else if (token.marketCap > 5000 && token.marketCap < 150000) {\n      score += 15;\n      factors.push('Good market cap');\n    } else if (token.marketCap < 5000) {\n      score += 5;\n      risks.push('Very small');\n    } else {\n      score -= 5;\n      risks.push('Too big');\n    }\n    \n    // Social (0-15 points)\n    if (token.socialSignals >= 3) {\n      score += 15;\n      factors.push('Strong social');\n    } else if (token.socialSignals >= 2) {\n      score += 10;\n      factors.push('Decent social');\n    } else {\n      score += 2;\n      risks.push('Weak social');\n    }\n    \n    // Platform bonuses (0-10 points)\n    if (token.platform === 'pump.fun') {\n      if (token.bondingProgress > 0.2 && token.bondingProgress < 0.8) {\n        score += 10;\n        factors.push('Active bonding');\n      } else if (token.isComplete) {\n        score -= 5;\n        risks.push('Graduated');\n      }\n    }\n    \n    // Finalize\n    token.scalpingViability = Math.max(0, Math.min(100, score));\n    token.scalpingFactors = factors;\n    token.scalpingRisks = risks;\n    token.scalpingGrade = score >= 80 ? 'A' : score >= 65 ? 'B' : score >= 50 ? 'C' : 'D';\n    \n    return token;\n  }).sort((a, b) => b.scalpingViability - a.scalpingViability);\n}\n\n// ===== MAIN EXECUTION =====\nasync function mainExecution() {\n  console.log('🔥 Starting complete scan execution...');\n  \n  try {\n    // Scan Pump.fun\n    let tokens = await scanPumpFunDebug();\n    \n    if (tokens.length === 0) {\n      console.warn('⚠️ No valid tokens from Pump.fun, using fallback...');\n      tokens = getDebugFallback();\n    }\n    \n    await delay(SCALPING_CONFIG.DELAY_BETWEEN_SOURCES);\n    \n    console.log(`📊 Processing ${tokens.length} tokens for scalping analysis...`);\n    \n    if (tokens.length === 0) {\n      console.error('❌ No tokens available');\n      return [{ json: { \n        symbol: 'NO-TOKENS', \n        error: 'No scalping candidates found',\n        portfolio: portfolioFromInput || {}\n      }}];\n    }\n    \n    // Calculate scores\n    const scoredTokens = calculateScalpingViability(tokens);\n    const bestToken = scoredTokens[0];\n    \n    // Add metadata\n    bestToken.portfolio = portfolioFromInput || {};\n    bestToken.timestamp = new Date().toISOString();\n    bestToken.scanner_version = 'debug-v1.0';\n    bestToken.totalCandidates = tokens.length;\n    bestToken.sourcesScanned = ['pump.fun'];\n    \n    // Final logging\n    console.log(`\\\\n🏆 BEST SCALPING CANDIDATE: ${bestToken.symbol} (${bestToken.name})`);\n    console.log(`🎯 Scalping Score: ${bestToken.scalpingViability}/100 (Grade: ${bestToken.scalpingGrade})`);\n    console.log(`💰 Market Cap: $${bestToken.marketCap?.toLocaleString()}`);\n    console.log(`📊 Volume 24h: $${bestToken.volume24h?.toLocaleString()}`);\n    console.log(`⏰ Age: ${bestToken.ageMinutes?.toFixed(1)} minutes`);\n    console.log(`🚨 Urgency: ${bestToken.urgency}`);\n    console.log(`✅ Factors: ${bestToken.scalpingFactors?.join(', ')}`);\n    console.log(`⚠️ Risks: ${bestToken.scalpingRisks?.join(', ')}`);\n    console.log(`📱 Social: ${bestToken.socialSignals}/4`);\n    console.log(`🔗 Source: ${bestToken.source}`);\n    \n    return [{ json: bestToken }];\n    \n  } catch (error) {\n    console.error('❌ Critical error in main execution:', error.message);\n    \n    const emergencyToken = {\n      symbol: 'EMERGENCY',\n      name: 'Emergency Fallback',\n      source: 'emergency-fallback',\n      error: error.message,\n      portfolio: portfolioFromInput || {}\n    };\n    \n    return [{ json: emergencyToken }];\n  }\n}\n\n// EXECUTE\nreturn mainExecution();"
      },
      "id": "35714e49-0872-4e12-9711-9d423acd3502",
      "name": "🔥 Multi-Platform Meme Scanner",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2180,
        280
      ],
      "alwaysOutputData": true,
      "notes": "AI Prompt generation REMOVED. Portfolio passed through. Enhanced risk indicators added to token objects and scoring."
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 2
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -2680,
        800
      ],
      "id": "55e64797-15d0-4625-9261-5da5a723d251",
      "name": "⏰ Auto-Sell Trigger"
    },
    {
      "parameters": {
        "jsCode": "// ===== 2. NODE \"📊 PF: Load Portfolio\" - VERSION SIMPLE =====\nconsole.log(\"📊 Load Portfolio - SIMPLE VERSION\");\n\n// Même portfolio que Init/View pour garantir la cohérence\nconst portfolio = {\n  balance: 9500,\n  openPositions: [\n    {\n      id: \"pos_test_scalp_001\",\n      symbol: \"TEST\",\n      name: \"Test Scalping Token\",\n      buyPrice: 0.001,\n      quantity: 500000,\n      timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago\n      status: \"OPEN\",\n      valueAtBuy: 500,\n      platform: \"pump.fun\",\n      address: \"test123...\"\n    }\n  ],\n  tradeHistory: [],\n  initialBalance: 10000,\n  portfolioStats: {\n    totalTrades: 1,\n    winningTrades: 0,\n    losingTrades: 0,\n    totalPnl: 0,\n    winRate: 0,\n    averagePnl: 0,\n    currentValue: 10000,\n    peakBalance: 10000,\n    lowestBalance: 9500\n  },\n  version: 1,\n  source: \"simple-load\"\n};\n\nconsole.log(\"✅ Portfolio loaded for auto-sell:\", {\n  balance: portfolio.balance,\n  positions: portfolio.openPositions.length,\n  age: \"5 minutes\"\n});\n\nreturn { json: { portfolio: portfolio } };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2460,
        800
      ],
      "id": "0995c761-cb07-4f8d-9bea-6634c5de6c02",
      "name": "📊 PF: Load Portfolio"
    },
    {
      "parameters": {
        "jsCode": "// 🧪 TEST DE VENTE FORCÉE - Modifie temporairement le node \"⚡ Scalping Auto-Sell System\"\n// Pour tester une vente, on va soit :\n// 1. Diminuer le seuil de take profit\n// 2. Forcer une simulation de prix plus élevée\n\nconsole.log(\"⚡ Scalping Auto-Sell - TEST SELL VERSION\");\n\nconst inputData = $input.item?.json;\nconst portfolio = inputData?.portfolio;\n\nconsole.log(\"📊 Received portfolio:\", {\n  balance: portfolio?.balance,\n  positions: portfolio?.openPositions?.length || 0\n});\n\nif (!portfolio || !portfolio.openPositions || portfolio.openPositions.length === 0) {\n  return { \n    json: { \n      scalpingAutoSellStatus: \"NO_POSITIONS\",\n      message: \"No positions found\",\n      timestamp: new Date().toISOString()\n    } \n  };\n}\n\n// 🧪 CONFIGURATION DE TEST - SEUILS PLUS BAS POUR FORCER UNE VENTE\nconst SCALPING_CONFIG = {\n// Dans \"⚡ Scalping Auto-Sell System\"\n  TAKE_PROFIT_TARGET: 25,    // Remet à 25% au lieu de 5%\n  STOP_LOSS_TARGET: -12,     // Stop loss à -12%\n  MAX_AGE_MINUTES: 240\n};\n\nconst sellSignals = [];\nconst holdSignals = [];\n\nfor (const position of portfolio.openPositions) {\n  const ageMinutes = (Date.now() - new Date(position.timestamp).getTime()) / (1000 * 60);\n  \n  console.log(`🎯 Analyzing ${position.symbol}:`, {\n    age: ageMinutes.toFixed(1) + \"min\",\n    platform: position.platform,\n    buyPrice: position.buyPrice\n  });\n  \n  // 🔥 SIMULATION FORCÉE - Prix plus élevé pour dépasser le seuil\n  const forcedPriceIncrease = 0.10; // +10% garanti\n  const currentPrice = position.buyPrice * (1 + forcedPriceIncrease);\n  const pnlPercentage = ((currentPrice - position.buyPrice) / position.buyPrice) * 100;\n  \n  console.log(`💰 FORCED Price simulation: $${currentPrice.toFixed(6)} (+${pnlPercentage.toFixed(2)}%)`);\n  \n  // Critères de vente avec seuils réduits\n  let shouldSell = false;\n  let reason = '';\n  let urgency = 'NORMAL';\n  \n  if (pnlPercentage >= SCALPING_CONFIG.TAKE_PROFIT_TARGET) {\n    shouldSell = true;\n    reason = `Take Profit: ${pnlPercentage.toFixed(2)}% (Target: ${SCALPING_CONFIG.TAKE_PROFIT_TARGET}%)`;\n    urgency = 'HIGH';\n  } else if (pnlPercentage <= SCALPING_CONFIG.STOP_LOSS_TARGET) {\n    shouldSell = true;\n    reason = `Stop Loss: ${pnlPercentage.toFixed(2)}%`;\n    urgency = 'EMERGENCY';\n  } else if (ageMinutes >= SCALPING_CONFIG.MAX_AGE_MINUTES) {\n    shouldSell = true;\n    reason = `Time Limit: ${ageMinutes.toFixed(0)}min`;\n    urgency = 'HIGH';\n  }\n  \n  const analysis = {\n    position: position,\n    metrics: {\n      currentPrice: currentPrice,\n      pnlPercentage: pnlPercentage,\n      pnlAbsolute: (currentPrice - position.buyPrice) * position.quantity,\n      ageMinutes: ageMinutes\n    },\n    analysis: {\n      shouldSell: shouldSell,\n      reason: reason,\n      urgency: urgency\n    },\n    timestamp: new Date().toISOString()\n  };\n  \n  if (shouldSell) {\n    sellSignals.push(analysis);\n    console.log(`⚡ SELL SIGNAL: ${position.symbol} - ${reason}`);\n  } else {\n    holdSignals.push(analysis);\n    console.log(`📊 HOLD: ${position.symbol} - ${pnlPercentage.toFixed(2)}% (Target: ${SCALPING_CONFIG.TAKE_PROFIT_TARGET}%)`);\n  }\n}\n\nconst result = {\n  scalpingAutoSellStatus: sellSignals.length > 0 ? \"SCALP_SELL_SIGNALS\" : \"SCALP_HOLDING\",\n  sellSignals: sellSignals,\n  holdSignals: holdSignals,\n  totalScalpPositions: portfolio.openPositions.length,\n  scalpSellCount: sellSignals.length,\n  scalpHoldCount: holdSignals.length,\n  portfolio: portfolio,\n  testMode: false,\n  configUsed: SCALPING_CONFIG,\n  timestamp: new Date().toISOString()\n};\n\nconsole.log(`\\n🧪 TEST ANALYSIS COMPLETE:`, {\n  positions: result.totalScalpPositions,\n  sellSignals: result.scalpSellCount,\n  holdSignals: result.scalpHoldCount,\n  takeProfitTarget: SCALPING_CONFIG.TAKE_PROFIT_TARGET + \"%\"\n});\n\nreturn { json: result };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2180,
        800
      ],
      "id": "aec7e7a4-1cab-4fbd-a239-2a9b69fabd29",
      "name": "⚡ Scalping Auto-Sell System"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "4c525f10-6a67-4d76-b422-5c4059b01d3d",
              "leftValue": "={{ $json.scalpSellCount || 0 }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1920,
        800
      ],
      "id": "58def3af-a61f-4565-852a-346532b33394",
      "name": "❓ Has Scalp Sells?"
    },
    {
      "parameters": {
        "jsCode": "// ===== 4. NODE \"💰 Execute Scalp Sell\" - VERSION SIMPLE =====\nconsole.log(\"💰 Execute Scalp Sell - SIMPLE VERSION\");\n\nconst inputData = $input.item?.json;\nconst sellSignals = inputData?.sellSignals || [];\nlet portfolio = inputData?.portfolio;\n\nif (!sellSignals || sellSignals.length === 0) {\n  return { json: { \n    executionStatus: \"NO_SELLS\",\n    message: \"No sell signals to execute\",\n    portfolio: portfolio\n  }};\n}\n\nconsole.log(`⚡ Executing ${sellSignals.length} sell(s)...`);\n\nconst executedSells = [];\n\nfor (const signal of sellSignals) {\n  const position = signal.position;\n  const metrics = signal.metrics;\n  \n  try {\n    // Calculer la vente\n    const sellAmountUSD = metrics.currentPrice * position.quantity;\n    const pnl = sellAmountUSD - position.valueAtBuy;\n    \n    // Mettre à jour portfolio\n    portfolio.balance += sellAmountUSD;\n    \n    // Supprimer position\n    const positionIndex = portfolio.openPositions.findIndex(p => p.id === position.id);\n    if (positionIndex !== -1) {\n      portfolio.openPositions.splice(positionIndex, 1);\n    }\n    \n    // Transaction\n    const sellTransaction = {\n      type: 'SCALP_SELL',\n      symbol: position.symbol,\n      buyPrice: position.buyPrice,\n      sellPrice: metrics.currentPrice,\n      quantity: position.quantity,\n      pnl: pnl,\n      pnlPercentage: metrics.pnlPercentage,\n      sellReason: signal.analysis.reason,\n      timestamp: new Date().toISOString(),\n      status: 'EXECUTED'\n    };\n    \n    portfolio.tradeHistory.push(sellTransaction);\n    \n    // Stats\n    portfolio.portfolioStats.totalTrades += 1;\n    portfolio.portfolioStats.totalPnl += pnl;\n    \n    if (pnl > 0) {\n      portfolio.portfolioStats.winningTrades += 1;\n    } else {\n      portfolio.portfolioStats.losingTrades += 1;\n    }\n    \n    // Recalculer win rate\n    const closedTrades = portfolio.portfolioStats.winningTrades + portfolio.portfolioStats.losingTrades;\n    if (closedTrades > 0) {\n      portfolio.portfolioStats.winRate = (portfolio.portfolioStats.winningTrades / closedTrades) * 100;\n    }\n    \n    executedSells.push(sellTransaction);\n    \n    console.log(`✅ SELL EXECUTED: ${position.symbol} - P&L: ${metrics.pnlPercentage.toFixed(2)}% ($${pnl.toFixed(2)})`);\n    \n  } catch (error) {\n    console.error(`❌ Failed to sell ${position.symbol}:`, error.message);\n  }\n}\n\nreturn { \n  json: { \n    executionStatus: \"EXECUTED\",\n    executedSells: executedSells,\n    totalExecuted: executedSells.length,\n    updatedPortfolio: portfolio,\n    scalpSummary: {\n      totalSells: executedSells.length,\n      totalPnl: executedSells.reduce((sum, sell) => sum + sell.pnl, 0),\n      avgPnlPercentage: executedSells.length > 0 ? \n        executedSells.reduce((sum, sell) => sum + sell.pnlPercentage, 0) / executedSells.length : 0\n    },\n    timestamp: new Date().toISOString()\n  } \n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1700,
        700
      ],
      "id": "906af177-7a01-4261-9495-a22958f4cca9",
      "name": "💰 Execute Scalp Sell"
    },
    {
      "parameters": {
        "chatId": "={{ $env.TELEGRAM_CHAT_ID }}",
        "text": "=⚡ SCALP SELL EXECUTED ⚡\n\n🎯 Scalp Summary:\n- Total Sells: {{ $json.totalExecuted }}\n- Total P&L: ${{ Number($json.scalpSummary.totalPnl).toFixed(2) }}\n- Average P&L: {{ Number($json.scalpSummary.avgPnlPercentage).toFixed(2) }}%\n- Average Hold Time: {{ Number($json.scalpSummary.avgHoldingTime).toFixed(0) }}min\n\n💰 Executed Scalps:\n{{ $json.executedSells.map(sell => `• ${sell.symbol}: ${sell.pnlPercentage.toFixed(2)}% (${sell.sellReason})`).join('\\n') }}\n\n📊 Portfolio Update:\n- Balance: ${{ Number($json.updatedPortfolio.balance).toFixed(2) }}\n- Open Positions: {{ $json.updatedPortfolio.openPositions.length }}\n- Total P&L: ${{ Number($json.updatedPortfolio.portfolioStats.totalPnl).toFixed(2) }}\n- Win Rate: {{ Number($json.updatedPortfolio.portfolioStats.winRate).toFixed(1) }}%\n\n⚡ Ultra-fast scalping system active!\n\n⏰ {{ $json.timestamp }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        -1480,
        700
      ],
      "id": "18f3aaad-73db-43f4-b236-a35700495229",
      "name": "🚨 Scalp Sell Alert (Telegram)",
      "webhookId": "ef618887-b5c7-4faa-af88-617b27364fd9",
      "credentials": {
        "telegramApi": {
          "id": "9Bu3duqjpOKytRFD",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// 🤖 AI ANALYSIS avec vraie API GROQ\nconsole.log(\"🤖 AI Analysis: Calling real Groq API...\");\n\nconst inputData = $input.item?.json;\nlet tokenData = inputData?.tokenData;\n\n// Fallback pour les données token\nif (!tokenData || tokenData.symbol === \"UNKNOWN\") {\n  tokenData = {\n    symbol: \"SCALP\",\n    name: \"Scalping Test Token\",\n    price: 0.00123,\n    marketCap: 67000,\n    volume24h: 28000,\n    ageMinutes: 47,\n    platform: \"pump.fun\",\n    scalpingViability: 80,\n    socialSignals: 3\n  };\n}\n\nconsole.log(\"🎯 Analyzing token:\", tokenData.symbol);\n\n// Construction du prompt pour Groq\nconst prompt = `You are an ELITE MEME COIN SCALPING EXPERT. \n\nANALYZE THIS TOKEN FOR SCALPING:\n- Symbol: ${tokenData.symbol}\n- Name: ${tokenData.name || 'Unknown'}\n- Price: $${tokenData.price || 0}\n- Market Cap: $${tokenData.marketCap?.toLocaleString() || 0}\n- Volume 24h: $${tokenData.volume24h?.toLocaleString() || 0}\n- Age: ${tokenData.ageMinutes || 0} minutes\n- Platform: ${tokenData.platform || 'unknown'}\n- Social Signals: ${tokenData.socialSignals || 0}/4\n- Scalping Viability: ${tokenData.scalpingViability || 0}/100\n\nRESPOND WITH VALID JSON ONLY:\n{\n  \"action\": \"BUY\" or \"SKIP\",\n  \"score\": 1-10,\n  \"risk\": 1-10,\n  \"confidence\": 1-100,\n  \"reasoning\": \"Brief analysis of why BUY or SKIP\",\n  \"scalping_analysis\": \"Detailed scalping assessment\",\n  \"entry_timing\": \"Is now the right time?\",\n  \"exit_strategy\": \"Profit target and stop loss\",\n  \"platform_risks\": \"Platform-specific risks\",\n  \"social_momentum\": \"Social signal assessment\",\n  \"security_grade\": \"A-F\",\n  \"estimated_profit_percentage\": 5-100,\n  \"estimated_loss_percentage\": 5-50,\n  \"trade_timeframe\": \"5min-4h\",\n  \"urgency_level\": \"LOW/MEDIUM/HIGH\",\n  \"key_metrics\": {\n    \"freshness_score\": 1-10,\n    \"volume_score\": 1-10,\n    \"social_score\": 1-10,\n    \"timing_score\": 1-10,\n    \"scalping_viability\": 1-10\n  }\n}`;\n\n// Configuration de la requête Groq\nconst groqRequest = {\n  method: 'POST',\n  url: 'https://api.groq.com/openai/v1/chat/completions',\n  headers: {\n    'Authorization': 'Bearer YOUR_GROQ_API_KEY', // ⚠️ Remplace par ta vraie clé\n    'Content-Type': 'application/json'\n  },\n  body: {\n    model: \"llama-3.3-70b-versatile\",\n    messages: [\n      {\n        role: \"user\",\n        content: prompt\n      }\n    ],\n    temperature: 0.7,\n    max_tokens: 1000\n  }\n};\n\ntry {\n  console.log(\"📡 Sending request to Groq...\");\n  \n  // Appel API Groq\n  const response = await this.helpers.httpRequest(groqRequest);\n  \n  console.log(\"✅ Groq response received\");\n  console.log(\"📊 Response status:\", response.status);\n  \n  return [{ json: response }];\n  \n} catch (error) {\n  console.error(\"❌ Groq API Error:\", error.message);\n  \n  // Fallback vers simulation en cas d'erreur API\n  console.log(\"🔄 Falling back to simulated analysis...\");\n  \n  const fallbackAnalysis = {\n    action: \"BUY\",\n    score: 8,\n    risk: 6,\n    confidence: 75,\n    reasoning: `Token ${tokenData.symbol} shows good scalping potential (Groq API fallback)`,\n    scalping_analysis: \"Fallback analysis due to API error\",\n    entry_timing: \"Timing appears favorable\",\n    exit_strategy: \"Target +25%, Stop -10%\",\n    platform_risks: \"Standard platform risks\",\n    social_momentum: \"Moderate social signals\",\n    security_grade: \"B\",\n    estimated_profit_percentage: 25,\n    estimated_loss_percentage: 15,\n    trade_timeframe: \"5min-4h\",\n    urgency_level: \"MEDIUM\",\n    key_metrics: {\n      freshness_score: 7,\n      volume_score: 8,\n      social_score: 6,\n      timing_score: 8,\n      scalping_viability: 7\n    }\n  };\n  \n  const fallbackResponse = {\n    choices: [{\n      message: {\n        content: JSON.stringify(fallbackAnalysis, null, 2)\n      }\n    }]\n  };\n  \n  return [{ json: fallbackResponse }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1100,
        80
      ],
      "id": "dde0e49a-6ac6-4b77-a493-8e918e070970",
      "name": "🤖 AI Analysis (Groq)"
    },
    {
      "parameters": {
        "jsCode": "// 🧠 SYSTÈME DE RÉTROACTION IA AUTO-APPRENANTE\n// Nouveau node à ajouter : \"🧠 AI Performance Analyzer\"\n\nconsole.log(\"🧠 AI Performance Analyzer: Starting adaptive learning...\");\n\nconst inputData = $input.item?.json;\nconst portfolio = inputData?.portfolio || {};\n\n// ===== COLLECTE DES DONNÉES DE PERFORMANCE =====\nclass AIPerformanceAnalyzer {\n  constructor() {\n    this.tradesHistory = portfolio.tradeHistory || [];\n    this.currentTimestamp = new Date().toISOString();\n  }\n\n  // Analyse des patterns gagnants\n  analyzeWinningPatterns() {\n    const recentTrades = this.tradesHistory.slice(-50); // 50 derniers trades\n    const winningTrades = recentTrades.filter(trade => (trade.pnl || 0) > 0);\n    const losingTrades = recentTrades.filter(trade => (trade.pnl || 0) < 0);\n\n    const patterns = {\n      winning: {\n        avgAge: this.calculateAverage(winningTrades.map(t => t.ageAtBuy || 0)),\n        avgMarketCap: this.calculateAverage(winningTrades.map(t => t.marketCapAtBuy || 0)),\n        avgVolume: this.calculateAverage(winningTrades.map(t => t.volumeAtBuy || 0)),\n        avgSocialSignals: this.calculateAverage(winningTrades.map(t => t.socialSignalsAtBuy || 0)),\n        avgHoldingTime: this.calculateAverage(winningTrades.map(t => t.holdingTimeMinutes || 0)),\n        platforms: this.getMostCommon(winningTrades.map(t => t.platform)),\n        timeOfDay: this.getMostCommon(winningTrades.map(t => new Date(t.timestamp).getHours()))\n      },\n      losing: {\n        avgAge: this.calculateAverage(losingTrades.map(t => t.ageAtBuy || 0)),\n        avgMarketCap: this.calculateAverage(losingTrades.map(t => t.marketCapAtBuy || 0)),\n        avgVolume: this.calculateAverage(losingTrades.map(t => t.volumeAtBuy || 0)),\n        avgSocialSignals: this.calculateAverage(losingTrades.map(t => t.socialSignalsAtBuy || 0))\n      }\n    };\n\n    return patterns;\n  }\n\n  // Génération de nouvelles configurations optimisées\n  generateOptimizedConfig(patterns) {\n    const currentConfig = {\n      MIN_AGE_MINUTES: 3,\n      MAX_AGE_MINUTES: 90,\n      MIN_MARKET_CAP: 1500,\n      MAX_MARKET_CAP: 150000,\n      MIN_VOLUME_24H: 8000,\n      MIN_SOCIAL_SIGNALS: 2\n    };\n\n    // Ajustements basés sur les patterns\n    const optimizedConfig = { ...currentConfig };\n\n    if (patterns.winning.avgAge > 0) {\n      // Ajuster l'âge optimal\n      const optimalAge = patterns.winning.avgAge;\n      optimizedConfig.MIN_AGE_MINUTES = Math.max(1, optimalAge - 10);\n      optimizedConfig.MAX_AGE_MINUTES = Math.min(120, optimalAge + 20);\n    }\n\n    if (patterns.winning.avgMarketCap > 0) {\n      // Ajuster la market cap optimale\n      const optimalMC = patterns.winning.avgMarketCap;\n      optimizedConfig.MIN_MARKET_CAP = Math.max(1000, optimalMC * 0.5);\n      optimizedConfig.MAX_MARKET_CAP = Math.min(500000, optimalMC * 2);\n    }\n\n    if (patterns.winning.avgVolume > 0) {\n      // Ajuster le volume minimal\n      optimizedConfig.MIN_VOLUME_24H = Math.max(5000, patterns.winning.avgVolume * 0.7);\n    }\n\n    return optimizedConfig;\n  }\n\n  // Prompt IA adaptatif basé sur l'apprentissage\n  generateAdaptiveAIPrompt(patterns, tokenData) {\n    const winRate = this.calculateWinRate();\n    const bestPerformingFactors = this.identifyBestFactors(patterns);\n\n    return `You are an ELITE MEME COIN SCALPING AI that LEARNS and ADAPTS.\n\n🧠 LEARNING DATA FROM YOUR PERFORMANCE:\n- Current Win Rate: ${winRate.toFixed(1)}%\n- Total Trades Analyzed: ${this.tradesHistory.length}\n- Best Performing Age Range: ${patterns.winning.avgAge?.toFixed(1) || 'N/A'} minutes\n- Best Market Cap Range: $${patterns.winning.avgMarketCap?.toLocaleString() || 'N/A'}\n- Best Volume Range: $${patterns.winning.avgVolume?.toLocaleString() || 'N/A'}\n- Most Profitable Platform: ${patterns.winning.platforms?.[0] || 'pump.fun'}\n- Best Trading Hours: ${patterns.winning.timeOfDay?.[0] || 'Various'}h\n\n🎯 TOP SUCCESS FACTORS (LEARNED):\n${bestPerformingFactors.map(factor => `• ${factor}`).join('\\\\n')}\n\n⚠️ FAILURE PATTERNS TO AVOID:\n• Tokens aged ${patterns.losing.avgAge?.toFixed(1) || 'N/A'} minutes tend to lose\n• Market caps around $${patterns.losing.avgMarketCap?.toLocaleString() || 'N/A'} underperform\n• Volume below $${patterns.losing.avgVolume?.toLocaleString() || 'N/A'} is risky\n\n🔍 CURRENT TOKEN TO ANALYZE:\n- Symbol: ${tokenData.symbol}\n- Age: ${tokenData.ageMinutes?.toFixed(1)} minutes\n- Market Cap: $${tokenData.marketCap?.toLocaleString()}\n- Volume: $${tokenData.volume24h?.toLocaleString()}\n- Social Signals: ${tokenData.socialSignals}/4\n- Platform: ${tokenData.platform}\n\n🧠 ADAPTIVE DECISION CRITERIA:\nBased on your learned patterns, this token ${this.getFitScore(tokenData, patterns)} your successful pattern.\n\nUse your learned intelligence to make a decision. You are getting smarter with each trade.\n\nRESPOND WITH JSON:\n{\n  \"action\": \"BUY\" or \"SKIP\",\n  \"score\": 1-10,\n  \"confidence\": 1-100,\n  \"reasoning\": \"Explain using YOUR LEARNED PATTERNS\",\n  \"adaptive_insights\": \"What patterns from your history influenced this decision\",\n  \"learning_weight\": 1-10 (how much this decision relies on learned patterns vs base criteria),\n  \"prediction_confidence\": 1-100 (based on similarity to past successful trades)\n}`;\n  }\n\n  // Méthodes utilitaires\n  calculateAverage(arr) {\n    return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;\n  }\n\n  getMostCommon(arr) {\n    const frequency = {};\n    arr.forEach(item => frequency[item] = (frequency[item] || 0) + 1);\n    return Object.keys(frequency).sort((a, b) => frequency[b] - frequency[a]);\n  }\n\n  calculateWinRate() {\n    const recentTrades = this.tradesHistory.slice(-30);\n    const wins = recentTrades.filter(trade => (trade.pnl || 0) > 0).length;\n    return recentTrades.length > 0 ? (wins / recentTrades.length) * 100 : 0;\n  }\n\n  identifyBestFactors(patterns) {\n    const factors = [];\n    \n    if (patterns.winning.avgAge < 30) factors.push(\"Ultra-fresh tokens (<30min) perform best\");\n    if (patterns.winning.avgMarketCap < 100000) factors.push(\"Mid-cap tokens are most profitable\");\n    if (patterns.winning.avgSocialSignals >= 2) factors.push(\"Social presence is crucial for success\");\n    if (patterns.winning.platforms?.[0]) factors.push(`${patterns.winning.platforms[0]} is your most profitable platform`);\n    \n    return factors;\n  }\n\n  getFitScore(tokenData, patterns) {\n    let score = 0;\n    let total = 0;\n\n    // Compare with winning patterns\n    if (patterns.winning.avgAge > 0) {\n      const ageDiff = Math.abs(tokenData.ageMinutes - patterns.winning.avgAge);\n      score += ageDiff < 20 ? 1 : 0;\n      total += 1;\n    }\n\n    if (patterns.winning.avgMarketCap > 0) {\n      const mcRatio = tokenData.marketCap / patterns.winning.avgMarketCap;\n      score += (mcRatio > 0.5 && mcRatio < 2) ? 1 : 0;\n      total += 1;\n    }\n\n    const fitPercentage = total > 0 ? (score / total) * 100 : 50;\n    return fitPercentage > 70 ? \"strongly matches\" : fitPercentage > 40 ? \"partially matches\" : \"differs from\";\n  }\n}\n\n// ===== EXÉCUTION PRINCIPALE =====\nasync function performAIAnalysis() {\n  const analyzer = new AIPerformanceAnalyzer();\n  \n  // Analyser les patterns\n  const patterns = analyzer.analyzeWinningPatterns();\n  \n  // Générer nouvelle config optimisée\n  const optimizedConfig = analyzer.generateOptimizedConfig(patterns);\n  \n  // Créer prompt adaptatif\n  const adaptivePrompt = analyzer.generateAdaptiveAIPrompt(patterns, inputData);\n\n  console.log(\"🧠 AI Analysis Results:\");\n  console.log(\"📊 Win Rate:\", analyzer.calculateWinRate().toFixed(1) + \"%\");\n  console.log(\"🎯 Optimal Age:\", patterns.winning.avgAge?.toFixed(1), \"minutes\");\n  console.log(\"💰 Optimal Market Cap:\", patterns.winning.avgMarketCap?.toLocaleString());\n  console.log(\"⚙️ New Config Generated:\", optimizedConfig.MIN_AGE_MINUTES, \"-\", optimizedConfig.MAX_AGE_MINUTES, \"min\");\n\n  return {\n    json: {\n      ...inputData,\n      aiAnalysis: patterns,\n      optimizedConfig: optimizedConfig,\n      adaptivePrompt: adaptivePrompt,\n      learningMetrics: {\n        totalTrades: analyzer.tradesHistory.length,\n        winRate: analyzer.calculateWinRate(),\n        adaptationLevel: analyzer.tradesHistory.length > 20 ? \"HIGH\" : analyzer.tradesHistory.length > 10 ? \"MEDIUM\" : \"LOW\"\n      },\n      timestamp: analyzer.currentTimestamp\n    }\n  };\n}\n\nreturn performAIAnalysis();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1500,
        500
      ],
      "id": "31575383-3ce1-45be-b4d8-52a4b65fc3c4",
      "name": "🧠 AI Performance Analyzer"
    },
    {
      "parameters": {
        "jsCode": "// 💰 PROFIT MAXIMIZER AI - VERSION COMPLÈTEMENT CORRIGÉE\nconsole.log(\"💰 Profit Maximizer: Starting FIXED profit analysis...\");\n\nconst inputData = $input.item?.json;\nconst tokenData = inputData?.tokenData || inputData || {};\nconst portfolio = inputData?.portfolio || {};\nconst currentBalance = portfolio.balance || 10000;\n\nconsole.log(\"🔍 Input Check:\", {\n  hasTokenData: !!tokenData.symbol,\n  tokenSymbol: tokenData.symbol,\n  tokenAge: tokenData.ageMinutes,\n  tokenMarketCap: tokenData.marketCap,\n  portfolioBalance: currentBalance,\n  scalpingScore: tokenData.scalpingViability\n});\n\n// ===== ANALYSEUR DE PROFIT CORRIGÉ =====\nclass FixedProfitAnalyzer {\n  constructor(tokenData, portfolio) {\n    this.token = tokenData;\n    this.portfolio = portfolio;\n    this.portfolioBalance = portfolio.balance || 10000;\n  }\n\n  // Calculer le potentiel de profit d'un token\n  calculateProfitPotential() {\n    let profitScore = 0;\n    let profitFactors = [];\n    let estimatedGain = 15; // Minimum 15% gain\n\n    console.log(\"🧮 Calculating profit for:\", this.token.symbol);\n\n    // Facteur 1: Âge optimal (0-25 points)\n    const age = this.token.ageMinutes || 30;\n    if (age >= 10 && age <= 45) {\n      profitScore += 25;\n      profitFactors.push(`Optimal age: ${age.toFixed(1)}min`);\n      estimatedGain += 20;\n    } else if (age >= 5 && age <= 60) {\n      profitScore += 15;\n      profitFactors.push(`Good age: ${age.toFixed(1)}min`);\n      estimatedGain += 12;\n    } else if (age <= 90) {\n      profitScore += 8;\n      estimatedGain += 8;\n    }\n\n    // Facteur 2: Market Cap Sweet Spot (0-20 points)\n    const mc = this.token.marketCap || 50000;\n    if (mc >= 20000 && mc <= 100000) {\n      profitScore += 20;\n      profitFactors.push(`Perfect market cap: $${mc.toLocaleString()}`);\n      estimatedGain += 18;\n    } else if (mc >= 10000 && mc <= 200000) {\n      profitScore += 15;\n      profitFactors.push(`Good market cap: $${mc.toLocaleString()}`);\n      estimatedGain += 12;\n    } else if (mc >= 5000) {\n      profitScore += 8;\n      estimatedGain += 8;\n    }\n\n    // Facteur 3: Volume pour liquidité (0-15 points)\n    const vol = this.token.volume24h || 15000;\n    if (vol > 25000) {\n      profitScore += 15;\n      profitFactors.push(`High liquidity: $${vol.toLocaleString()}`);\n      estimatedGain += 12;\n    } else if (vol > 10000) {\n      profitScore += 12;\n      profitFactors.push(`Good liquidity: $${vol.toLocaleString()}`);\n      estimatedGain += 8;\n    } else if (vol > 5000) {\n      profitScore += 8;\n      estimatedGain += 5;\n    }\n\n    // Facteur 4: Scalping Score (0-15 points)\n    const scalpScore = this.token.scalpingViability || 70;\n    if (scalpScore >= 80) {\n      profitScore += 15;\n      profitFactors.push(`Excellent scalping score: ${scalpScore}`);\n      estimatedGain += 15;\n    } else if (scalpScore >= 70) {\n      profitScore += 12;\n      profitFactors.push(`Good scalping score: ${scalpScore}`);\n      estimatedGain += 10;\n    } else if (scalpScore >= 60) {\n      profitScore += 8;\n      estimatedGain += 8;\n    } else {\n      profitScore += 5;\n      estimatedGain += 5;\n    }\n\n    // Facteur 5: Social Momentum (0-10 points)\n    const social = this.token.socialSignals || 1;\n    if (social >= 3) {\n      profitScore += 10;\n      profitFactors.push(`Strong social signals: ${social}/4`);\n      estimatedGain += 15;\n    } else if (social >= 2) {\n      profitScore += 8;\n      profitFactors.push(`Decent social signals: ${social}/4`);\n      estimatedGain += 8;\n    } else {\n      profitScore += 4;\n      estimatedGain += 5;\n    }\n\n    // Facteur 6: Platform Bonus (0-10 points)\n    if (this.token.platform === 'pump.fun') {\n      const bonding = this.token.bondingProgress || 0.5;\n      if (bonding > 0.2 && bonding < 0.8) {\n        profitScore += 10;\n        profitFactors.push(`Active bonding: ${(bonding * 100).toFixed(1)}%`);\n        estimatedGain += 12;\n      } else {\n        profitScore += 5;\n        estimatedGain += 5;\n      }\n    }\n\n    // Facteur 7: Urgency Bonus (0-5 points)\n    const urgency = this.token.urgency || 'MEDIUM';\n    if (urgency === 'ULTRA_HIGH') {\n      profitScore += 5;\n      estimatedGain += 8;\n    } else if (urgency === 'HIGH') {\n      profitScore += 4;\n      estimatedGain += 6;\n    } else if (urgency === 'MEDIUM') {\n      profitScore += 2;\n      estimatedGain += 3;\n    }\n\n    // Calcul final\n    const finalProfitScore = Math.min(100, Math.max(20, profitScore)); // Min 20, Max 100\n    const estimatedProfitPercentage = Math.min(60, Math.max(15, estimatedGain)); // Min 15%, Max 60%\n\n    console.log(\"💎 Profit Calculation Results:\", {\n      finalProfitScore: finalProfitScore,\n      estimatedProfitPercentage: estimatedProfitPercentage,\n      factorsCount: profitFactors.length\n    });\n\n    return {\n      profitScore: finalProfitScore,\n      profitGrade: finalProfitScore >= 85 ? 'A+' : finalProfitScore >= 75 ? 'A' : finalProfitScore >= 65 ? 'B+' : finalProfitScore >= 55 ? 'B' : finalProfitScore >= 45 ? 'C+' : 'C',\n      estimatedProfitPercentage: estimatedProfitPercentage,\n      profitFactors: profitFactors,\n      riskAdjustedReturn: estimatedProfitPercentage / Math.max(1, (10 - scalpScore / 10)),\n      recommendedPositionSize: this.calculateOptimalPositionSize(finalProfitScore, estimatedProfitPercentage)\n    };\n  }\n\n  // POSITION SIZING CORRIGÉ - GARANTIT TOUJOURS UNE VALEUR > 0\n  calculateOptimalPositionSize(profitScore, estimatedProfit) {\n    console.log(\"💸 Calculating position size:\", {\n      profitScore: profitScore,\n      estimatedProfit: estimatedProfit,\n      portfolioBalance: this.portfolioBalance\n    });\n\n    const baseSize = 450; // $450 position de base (augmenté)\n    const maxSize = this.portfolioBalance * 0.15; // Max 15% du portfolio\n    const minSize = 350; // Minimum garanti $350\n    \n    let multiplier = 1;\n    \n    // Calcul du multiplier basé sur le profit score ET estimated profit\n    if (profitScore >= 80 && estimatedProfit >= 35) {\n      multiplier = 2.2; // 2.2x pour opportunités exceptionnelles\n    } else if (profitScore >= 70 && estimatedProfit >= 28) {\n      multiplier = 1.9; // 1.9x pour excellentes opportunités  \n    } else if (profitScore >= 60 && estimatedProfit >= 22) {\n      multiplier = 1.6; // 1.6x pour bonnes opportunités\n    } else if (profitScore >= 50 && estimatedProfit >= 18) {\n      multiplier = 1.3; // 1.3x pour opportunités correctes\n    } else if (profitScore >= 40) {\n      multiplier = 1.0; // 1x pour opportunités moyennes\n    } else {\n      multiplier = 0.8; // 0.8x pour opportunités faibles (mais minimum garanti)\n    }\n\n    const calculatedSize = baseSize * multiplier;\n    const finalSize = Math.min(maxSize, Math.max(minSize, calculatedSize));\n\n    console.log(\"💸 Position Size Final:\", {\n      baseSize: baseSize,\n      multiplier: multiplier,\n      calculatedSize: calculatedSize,\n      maxSize: maxSize,\n      minSize: minSize,\n      finalSize: finalSize\n    });\n\n    return Math.round(finalSize); // Arrondir pour éviter les décimales\n  }\n\n  // Calculer timing optimal\n  calculateOptimalTiming() {\n    const currentHour = new Date().getUTCHours();\n    let timingScore = 30; // Score de base plus élevé\n    let timingFactors = [];\n\n    // Heures généralement profitables pour crypto (UTC)\n    const profitableHours = [13, 14, 15, 16, 19, 20, 21, 22];\n    \n    if (profitableHours.includes(currentHour)) {\n      timingScore += 25;\n      timingFactors.push(`Profitable hour: ${currentHour}h UTC`);\n    } else {\n      timingScore += 10;\n    }\n\n    // Freshness timing\n    const age = this.token.ageMinutes || 30;\n    if (age >= 15 && age <= 45) {\n      timingScore += 25;\n      timingFactors.push(`Perfect freshness: ${age.toFixed(1)}min`);\n    } else if (age >= 5 && age <= 60) {\n      timingScore += 15;\n      timingFactors.push(`Good freshness: ${age.toFixed(1)}min`);\n    } else {\n      timingScore += 5;\n    }\n\n    // Urgency factor\n    const urgency = this.token.urgency || 'MEDIUM';\n    if (urgency === 'ULTRA_HIGH') {\n      timingScore += 20;\n      timingFactors.push('Ultra high urgency');\n    } else if (urgency === 'HIGH') {\n      timingScore += 15;\n      timingFactors.push('High urgency');\n    } else if (urgency === 'MEDIUM') {\n      timingScore += 10;\n      timingFactors.push('Medium urgency');\n    }\n\n    const finalTimingScore = Math.min(100, timingScore);\n\n    return {\n      timingScore: finalTimingScore,\n      timingGrade: finalTimingScore >= 70 ? 'OPTIMAL' : finalTimingScore >= 50 ? 'GOOD' : 'AVERAGE',\n      timingFactors: timingFactors,\n      entryRecommendation: finalTimingScore >= 60 ? 'ENTER_NOW' : finalTimingScore >= 40 ? 'ENTER_SOON' : 'WAIT'\n    };\n  }\n\n  // STRATÉGIE CORRIGÉE - TOUJOURS POSITIVE\n  generateMaxProfitStrategy(profitAnalysis, timingAnalysis) {\n    const strategy = {\n      action: 'BUY', // Par défaut BUY au lieu de SKIP\n      confidence: 60,\n      expectedROI: profitAnalysis.estimatedProfitPercentage,\n      positionSize: profitAnalysis.recommendedPositionSize,\n      reasoning: '',\n      profitTarget: profitAnalysis.estimatedProfitPercentage,\n      stopLoss: -12,\n      maxHoldingTime: '3h',\n      urgencyLevel: 'MEDIUM'\n    };\n\n    console.log(\"🎯 Strategy Decision Inputs:\", {\n      profitScore: profitAnalysis.profitScore,\n      timingScore: timingAnalysis.timingScore,\n      estimatedProfit: profitAnalysis.estimatedProfitPercentage,\n      positionSize: profitAnalysis.recommendedPositionSize\n    });\n\n    // Décision basée sur profit potential (seuils abaissés pour plus de trades)\n    if (profitAnalysis.profitScore >= 70 && timingAnalysis.timingScore >= 50) {\n      strategy.action = 'AGGRESSIVE_BUY';\n      strategy.confidence = 85;\n      strategy.reasoning = `AGGRESSIVE: ${profitAnalysis.profitGrade} grade, ${profitAnalysis.estimatedProfitPercentage}% expected ROI`;\n      strategy.stopLoss = -10;\n      strategy.maxHoldingTime = '2h';\n      strategy.urgencyLevel = 'ULTRA_HIGH';\n      \n    } else if (profitAnalysis.profitScore >= 55 && profitAnalysis.estimatedProfitPercentage >= 18) {\n      strategy.action = 'BUY';\n      strategy.confidence = 75;\n      strategy.reasoning = `GOOD PROFIT: ${profitAnalysis.profitGrade} grade, ${profitAnalysis.estimatedProfitPercentage}% expected`;\n      strategy.urgencyLevel = 'HIGH';\n      \n    } else if (profitAnalysis.profitScore >= 40) {\n      strategy.action = 'BUY';\n      strategy.confidence = 65;\n      strategy.reasoning = `MODERATE: ${profitAnalysis.profitGrade} grade, conservative approach`;\n      strategy.expectedROI = Math.max(15, profitAnalysis.estimatedProfitPercentage);\n      strategy.urgencyLevel = 'MEDIUM';\n      \n    } else {\n      // Même pour les scores bas, on peut trader avec position réduite\n      strategy.action = 'BUY';\n      strategy.confidence = 50;\n      strategy.positionSize = Math.min(strategy.positionSize, 400);\n      strategy.reasoning = `LOW RISK: Small position, ${profitAnalysis.estimatedProfitPercentage}% target`;\n      strategy.urgencyLevel = 'LOW';\n    }\n\n    console.log(\"🎯 Final Strategy:\", {\n      action: strategy.action,\n      expectedROI: strategy.expectedROI,\n      positionSize: strategy.positionSize,\n      urgencyLevel: strategy.urgencyLevel\n    });\n\n    return strategy;\n  }\n}\n\n// ===== EXÉCUTION PRINCIPALE =====\nasync function executeFixedProfit() {\n  try {\n    console.log(\"🚀 Starting FIXED profit analysis...\");\n    \n    const analyzer = new FixedProfitAnalyzer(tokenData, portfolio);\n    \n    const profitAnalysis = analyzer.calculateProfitPotential();\n    const timingAnalysis = analyzer.calculateOptimalTiming();\n    const maxProfitStrategy = analyzer.generateMaxProfitStrategy(profitAnalysis, timingAnalysis);\n\n    console.log(\"💰 FIXED PROFIT ANALYSIS RESULTS:\");\n    console.log(\"🎯 Profit Score:\", profitAnalysis.profitScore + \"/100\");\n    console.log(\"💎 Expected ROI:\", profitAnalysis.estimatedProfitPercentage + \"%\");\n    console.log(\"📊 Grade:\", profitAnalysis.profitGrade);\n    console.log(\"⚡ Strategy:\", maxProfitStrategy.action);\n    console.log(\"💸 Position Size: $\" + maxProfitStrategy.positionSize);\n    console.log(\"🔥 Urgency:\", maxProfitStrategy.urgencyLevel);\n\n    return {\n      json: {\n        ...inputData,\n        profitAnalysis: profitAnalysis,\n        timingAnalysis: timingAnalysis,\n        maxProfitStrategy: maxProfitStrategy,\n        profitOptimization: {\n          enabled: true,\n          version: 'fixed-profit-v1.1',\n          timestamp: new Date().toISOString(),\n          positionSizeGuaranteed: true\n        }\n      }\n    };\n    \n  } catch (error) {\n    console.error(\"❌ Profit analysis error:\", error.message);\n    \n    // Fallback robuste avec position size garantie\n    return {\n      json: {\n        ...inputData,\n        profitAnalysis: {\n          profitScore: 60,\n          profitGrade: 'B',\n          estimatedProfitPercentage: 22,\n          profitFactors: ['Fallback analysis'],\n          recommendedPositionSize: 500 // Position garantie\n        },\n        maxProfitStrategy: {\n          action: 'BUY',\n          expectedROI: 22,\n          positionSize: 500, // Position garantie\n          reasoning: 'Fallback strategy with guaranteed position',\n          urgencyLevel: 'MEDIUM'\n        }\n      }\n    };\n  }\n}\n\nreturn executeFixedProfit();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1300,
        320
      ],
      "id": "ffc63149-250a-4bf6-b24d-d2a506fed577",
      "name": "💰 Profit Maximizer AI"
    }
  ],
  "pinData": {},
  "connections": {
    "⏰ Trigger Scan (Cron)": {
      "main": [
        [
          {
            "node": "PF: Init/View",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PF: Init/View": {
      "main": [
        [
          {
            "node": "🔥 Multi-Platform Meme Scanner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🎯 Smart Filter & Merge Portfolio": {
      "main": [
        [
          {
            "node": "📰 Get News Sentiment (Simulated)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "📰 Get News Sentiment (Simulated)": {
      "main": [
        [
          {
            "node": "🤖 AI Analysis (Groq)",
            "type": "main",
            "index": 0
          },
          {
            "node": "🧠 AI Performance Analyzer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Manual Sell": {
      "main": [
        [
          {
            "node": "PF: Init/View",
            "type": "main",
            "index": 0
          },
          {
            "node": "💰 Set Sell Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "💡 Trading Decision Logic": {
      "main": [
        [
          {
            "node": "🚨 Is Real Error?",
            "type": "main",
            "index": 0
          },
          {
            "node": "🤔 Buy or Skip?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PF: Record Buy": {
      "main": [
        [
          {
            "node": "✅ BUY Alert (Telegram)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🤔 Buy or Skip?": {
      "main": [
        [
          {
            "node": "PF: Record Buy",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "❌ SKIP Alert (Telegram)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PF: Record Sell": {
      "main": [
        [
          {
            "node": "📱 SELL Alert (Telegram)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "💰 Set Sell Details": {
      "main": [
        [
          {
            "node": "PF: Record Sell",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔗 Merge AI Output & Context": {
      "main": [
        [
          {
            "node": "💡 Trading Decision Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🤖 Generate AI Prompt with News & Risk": {
      "main": [
        [
          {
            "node": "🔗 Merge AI Output & Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🚨 Is Real Error?": {
      "main": [
        [
          {
            "node": "🚨 ERROR Alert (Telegram)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔥 Multi-Platform Meme Scanner": {
      "main": [
        [
          {
            "node": "🎯 Smart Filter & Merge Portfolio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "⏰ Auto-Sell Trigger": {
      "main": [
        [
          {
            "node": "📊 PF: Load Portfolio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "📊 PF: Load Portfolio": {
      "main": [
        [
          {
            "node": "⚡ Scalping Auto-Sell System",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "⚡ Scalping Auto-Sell System": {
      "main": [
        [
          {
            "node": "❓ Has Scalp Sells?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "❓ Has Scalp Sells?": {
      "main": [
        [
          {
            "node": "💰 Execute Scalp Sell",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "💰 Execute Scalp Sell": {
      "main": [
        [
          {
            "node": "🚨 Scalp Sell Alert (Telegram)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🤖 AI Analysis (Groq)": {
      "main": [
        [
          {
            "node": "🔗 Merge AI Output & Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🧠 AI Performance Analyzer": {
      "main": [
        [
          {
            "node": "🤖 Generate AI Prompt with News & Risk",
            "type": "main",
            "index": 0
          },
          {
            "node": "💰 Profit Maximizer AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "💰 Profit Maximizer AI": {
      "main": [
        [
          {
            "node": "🤖 AI Analysis (Groq)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "❌ SKIP Alert (Telegram)": {
      "main": [
        []
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a4856798-5458-456d-983a-63e0159a0517",
  "meta": {
    "instanceId": "3fff4939e8445b379bb6ca4cf749919e3282e4f054763342a3803bc5bba48aca"
  },
  "id": "myKhWq5w6ztSeewc",
  "tags": [
    {
      "createdAt": "2025-05-25T22:07:35.317Z",
      "updatedAt": "2025-05-25T22:07:35.317Z",
      "id": "D0ssehyA9lWYIpio",
      "name": "Social Sentiment"
    },
    {
      "createdAt": "2025-05-25T22:07:35.321Z",
      "updatedAt": "2025-05-25T22:07:35.321Z",
      "id": "mwj3U1KEh2RL1QfY",
      "name": "Risk Assessment"
    },
    {
      "createdAt": "2025-05-25T22:07:35.339Z",
      "updatedAt": "2025-05-25T22:07:35.339Z",
      "id": "DIkkU0I5frYa1YEG",
      "name": "Crypto Bot v1.5 Fixed"
    }
  ]
}