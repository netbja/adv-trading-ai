// üéØ WORKFLOW 2: TECHNICAL TRADING - ARCHITECTURE COMPL√àTE
// Fichier: n8n-workflows/02-technical-trading.json

/*
WORKFLOW STRUCTURE:
‚è∞ Cron (1h) ‚Üí üìä Established Scanner ‚Üí üîç Technical Analysis ‚Üí üìà Decision ‚Üí üíé Execute
                        ‚Üì                        ‚Üì                  ‚Üì
                CoinGecko API ‚Üí RSI/MACD/Bollinger ‚Üí Position Manager
                        ‚Üì                        ‚Üì                  ‚Üì
              üß† Shared Brain ‚Üê Performance Tracker ‚Üê Portfolio Update
*/

// ===== NODE 1: TRIGGER (1H CRON) =====
const triggerNode = {
    name: "‚è∞ Technical Trading Trigger",
    type: "n8n-nodes-base.cron",
    position: [20, 20],
    parameters: {
      rule: {
        hour: "*",  // Toutes les heures
        timezone: "Europe/Paris"
      }
    }
  };
  
  // ===== NODE 2: ESTABLISHED TOKEN SCANNER =====
  const establishedScannerNode = {
    name: "üìä Established Token Scanner",
    type: "n8n-nodes-base.code",
    position: [240, 20],
    parameters: {
      mode: "runOnceForAllItems",
      jsCode: `
  // üìä SCANNER DE TOKENS √âTABLIS - TOP 100 COINGECKO
  console.log("üìä Starting Established Token Scanner...");
  
  // Liste des tokens √©tablis (top marketcap)
  const ESTABLISHED_TOKENS = [
    // Top 10 par marketcap
    { symbol: "BTC", id: "bitcoin", name: "Bitcoin" },
    { symbol: "ETH", id: "ethereum", name: "Ethereum" },
    { symbol: "BNB", id: "binancecoin", name: "Binance Coin" },
    { symbol: "SOL", id: "solana", name: "Solana" },
    { symbol: "XRP", id: "ripple", name: "XRP" },
    { symbol: "ADA", id: "cardano", name: "Cardano" },
    { symbol: "AVAX", id: "avalanche-2", name: "Avalanche" },
    { symbol: "DOT", id: "polkadot", name: "Polkadot" },
    { symbol: "MATIC", id: "matic-network", name: "Polygon" },
    { symbol: "LINK", id: "chainlink", name: "Chainlink" },
    
    // DeFi tokens
    { symbol: "UNI", id: "uniswap", name: "Uniswap" },
    { symbol: "AAVE", id: "aave", name: "Aave" },
    { symbol: "MKR", id: "maker", name: "Maker" },
    { symbol: "COMP", id: "compound-governance-token", name: "Compound" },
    
    // Layer 2
    { symbol: "ARB", id: "arbitrum", name: "Arbitrum" },
    { symbol: "OP", id: "optimism", name: "Optimism" },
    
    // Gaming/NFT
    { symbol: "SAND", id: "the-sandbox", name: "The Sandbox" },
    { symbol: "MANA", id: "decentraland", name: "Decentraland" }
  ];
  
  try {
    // R√©cup√©rer les donn√©es de march√© pour tous les tokens
    const tokenIds = ESTABLISHED_TOKENS.map(t => t.id).join(',');
    
    const marketDataUrl = \`https://api.coingecko.com/api/v3/coins/markets?\` +
      \`vs_currency=usd&\` +
      \`ids=\${tokenIds}&\` +
      \`order=market_cap_desc&\` +
      \`per_page=50&\` +
      \`page=1&\` +
      \`sparkline=true&\` +
      \`price_change_percentage=1h,24h,7d,30d\`;
  
    const response = await fetch(marketDataUrl);
    const marketData = await response.json();
    
    // Enrichir avec donn√©es techniques
    const enrichedTokens = marketData.map(token => {
      const established = ESTABLISHED_TOKENS.find(t => t.id === token.id);
      
      return {
        // Infos de base
        symbol: token.symbol.toUpperCase(),
        name: token.name,
        id: token.id,
        
        // Prix et market cap
        price: token.current_price,
        marketCap: token.market_cap,
        volume24h: token.total_volume,
        rank: token.market_cap_rank,
        
        // Changements de prix
        priceChange1h: token.price_change_percentage_1h_in_currency || 0,
        priceChange24h: token.price_change_percentage_24h || 0,
        priceChange7d: token.price_change_percentage_7d_in_currency || 0,
        priceChange30d: token.price_change_percentage_30d_in_currency || 0,
        
        // Donn√©es pour analyse technique
        high24h: token.high_24h,
        low24h: token.low_24h,
        ath: token.ath,
        athDate: token.ath_date,
        atl: token.atl,
        atlDate: token.atl_date,
        
        // Sparkline pour calculs techniques
        sparkline: token.sparkline_in_7d?.price || [],
        
        // M√©tadonn√©es
        lastUpdated: new Date().toISOString(),
        category: "ESTABLISHED",
        
        // Scores pr√©liminaires
        liquidityScore: Math.min(100, (token.total_volume / token.market_cap) * 1000),
        volatilityScore: Math.abs(token.price_change_percentage_24h || 0),
        trendScore: (token.price_change_percentage_7d_in_currency || 0) > 0 ? 1 : -1
      };
    });
    
    console.log(\`‚úÖ Scanner completed: \${enrichedTokens.length} established tokens found\`);
    console.log("üìä Top 5 by volume:", enrichedTokens.slice(0, 5).map(t => \`\${t.symbol}: $\${t.volume24h?.toLocaleString()}\`));
    
    return [{ 
      json: {
        tokens: enrichedTokens,
        scanTimestamp: new Date().toISOString(),
        totalScanned: enrichedTokens.length,
        scanType: "ESTABLISHED_TOKENS"
      }
    }];
    
  } catch (error) {
    console.error("‚ùå Scanner error:", error);
    
    // Fallback avec donn√©es minimales
    const fallbackTokens = ESTABLISHED_TOKENS.slice(0, 5).map(token => ({
      symbol: token.symbol,
      name: token.name,
      id: token.id,
      price: 1000 + Math.random() * 50000,
      marketCap: 1000000000 + Math.random() * 100000000000,
      volume24h: 100000000 + Math.random() * 1000000000,
      priceChange24h: (Math.random() - 0.5) * 20,
      category: "ESTABLISHED",
      scanTimestamp: new Date().toISOString()
    }));
    
    return [{ 
      json: {
        tokens: fallbackTokens,
        scanTimestamp: new Date().toISOString(),
        totalScanned: fallbackTokens.length,
        scanType: "ESTABLISHED_TOKENS_FALLBACK",
        error: error.message
      }
    }];
  }
  `
    }
  };
  
  // ===== NODE 3: TECHNICAL ANALYSIS ENGINE =====
  const technicalAnalysisNode = {
    name: "üîç Technical Analysis Engine",
    type: "n8n-nodes-base.code",
    position: [460, 20],
    parameters: {
      mode: "runOnceForAllItems",
      jsCode: `
  // üîç MOTEUR D'ANALYSE TECHNIQUE AVANC√â
  console.log("üîç Starting Technical Analysis Engine...");
  
  const inputData = $input.first().json;
  const tokens = inputData.tokens || [];
  
  // ===== FONCTIONS D'ANALYSE TECHNIQUE =====
  
  // Calcul RSI (Relative Strength Index)
  function calculateRSI(prices, period = 14) {
    if (prices.length < period + 1) return 50; // Neutre si pas assez de donn√©es
    
    let gains = 0, losses = 0;
    
    // Calculer les gains et pertes moyens
    for (let i = 1; i <= period; i++) {
      const change = prices[i] - prices[i - 1];
      if (change > 0) gains += change;
      else losses += Math.abs(change);
    }
    
    const avgGain = gains / period;
    const avgLoss = losses / period;
    
    if (avgLoss === 0) return 100;
    
    const RS = avgGain / avgLoss;
    const RSI = 100 - (100 / (1 + RS));
    
    return Math.round(RSI * 100) / 100;
  }
  
  // Calcul MACD (Moving Average Convergence Divergence)
  function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    if (prices.length < slowPeriod) return { macd: 0, signal: 0, histogram: 0 };
    
    // EMA rapide et lente
    const fastEMA = calculateEMA(prices, fastPeriod);
    const slowEMA = calculateEMA(prices, slowPeriod);
    
    const macd = fastEMA - slowEMA;
    
    // Signal line (EMA du MACD)
    const macdLine = [macd]; // Simplifi√© pour demo
    const signal = calculateEMA(macdLine, signalPeriod);
    
    return {
      macd: Math.round(macd * 10000) / 10000,
      signal: Math.round(signal * 10000) / 10000,
      histogram: Math.round((macd - signal) * 10000) / 10000
    };
  }
  
  // Calcul EMA (Exponential Moving Average)
  function calculateEMA(prices, period) {
    if (prices.length === 0) return 0;
    
    const multiplier = 2 / (period + 1);
    let ema = prices[0];
    
    for (let i = 1; i < prices.length; i++) {
      ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
    }
    
    return ema;
  }
  
  // Calcul Bollinger Bands
  function calculateBollingerBands(prices, period = 20, stdDev = 2) {
    if (prices.length < period) return { upper: 0, middle: 0, lower: 0, position: 0.5 };
    
    const recentPrices = prices.slice(-period);
    const sma = recentPrices.reduce((a, b) => a + b, 0) / period;
    
    // √âcart-type
    const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
    const standardDeviation = Math.sqrt(variance);
    
    const upper = sma + (standardDeviation * stdDev);
    const lower = sma - (standardDeviation * stdDev);
    const currentPrice = prices[prices.length - 1];
    
    // Position dans les bandes (0 = lower, 0.5 = middle, 1 = upper)
    const position = (currentPrice - lower) / (upper - lower);
    
    return {
      upper: Math.round(upper * 100) / 100,
      middle: Math.round(sma * 100) / 100,
      lower: Math.round(lower * 100) / 100,
      position: Math.max(0, Math.min(1, position))
    };
  }
  
  // Support et R√©sistance
  function calculateSupportResistance(prices, high24h, low24h) {
    const currentPrice = prices[prices.length - 1];
    
    // Support/r√©sistance bas√©s sur les extr√™mes
    const support = low24h;
    const resistance = high24h;
    
    // Distance par rapport aux niveaux
    const supportDistance = (currentPrice - support) / support;
    const resistanceDistance = (resistance - currentPrice) / currentPrice;
    
    return {
      support: support,
      resistance: resistance,
      supportDistance: Math.round(supportDistance * 10000) / 100, // en %
      resistanceDistance: Math.round(resistanceDistance * 10000) / 100, // en %
      nearSupport: supportDistance < 0.05, // Moins de 5% du support
      nearResistance: resistanceDistance < 0.05 // Moins de 5% de la r√©sistance
    };
  }
  
  // ===== ANALYSE DE CHAQUE TOKEN =====
  const analyzedTokens = tokens.map(token => {
    try {
      // Utiliser sparkline comme prix historiques
      const prices = token.sparkline && token.sparkline.length > 0 
        ? token.sparkline 
        : [token.price * 0.95, token.price * 0.98, token.price]; // Fallback
      
      // Calculs techniques
      const rsi = calculateRSI(prices);
      const macd = calculateMACD(prices);
      const bollinger = calculateBollingerBands(prices);
      const supportResistance = calculateSupportResistance(prices, token.high24h, token.low24h);
      
      // ===== SIGNAUX DE TRADING =====
      const signals = {
        // RSI Signals
        rsiOversold: rsi < 30,
        rsiOverbought: rsi > 70,
        rsiNeutral: rsi >= 30 && rsi <= 70,
        
        // MACD Signals
        macdBullish: macd.macd > macd.signal && macd.histogram > 0,
        macdBearish: macd.macd < macd.signal && macd.histogram < 0,
        
        // Bollinger Signals
        bollingerOversold: bollinger.position < 0.2,
        bollingerOverbought: bollinger.position > 0.8,
        
        // Support/Resistance
        nearSupport: supportResistance.nearSupport,
        nearResistance: supportResistance.nearResistance,
        
        // Trend Signals
        uptrend: token.priceChange7d > 5 && token.priceChange24h > 0,
        downtrend: token.priceChange7d < -5 && token.priceChange24h < 0
      };
      
      // ===== SCORE DE TRADING =====
      let tradingScore = 50; // Base neutre
      
      // RSI Impact
      if (signals.rsiOversold) tradingScore += 20;
      if (signals.rsiOverbought) tradingScore -= 15;
      
      // MACD Impact
      if (signals.macdBullish) tradingScore += 15;
      if (signals.macdBearish) tradingScore -= 10;
      
      // Bollinger Impact
      if (signals.bollingerOversold) tradingScore += 10;
      if (signals.bollingerOverbought) tradingScore -= 10;
      
      // Support/Resistance Impact
      if (signals.nearSupport) tradingScore += 15;
      if (signals.nearResistance) tradingScore -= 10;
      
      // Trend Impact
      if (signals.uptrend) tradingScore += 10;
      if (signals.downtrend) tradingScore -= 15;
      
      // Volume Impact (liquidit√©)
      if (token.liquidityScore > 50) tradingScore += 5;
      
      // Limiter le score entre 0 et 100
      tradingScore = Math.max(0, Math.min(100, tradingScore));
      
      // ===== RECOMMANDATION =====
      let recommendation = "HOLD";
      if (tradingScore >= 75) recommendation = "STRONG_BUY";
      else if (tradingScore >= 65) recommendation = "BUY";
      else if (tradingScore <= 25) recommendation = "STRONG_SELL";
      else if (tradingScore <= 35) recommendation = "SELL";
      
      return {
        ...token,
        
        // Indicateurs techniques
        technicalIndicators: {
          rsi: rsi,
          macd: macd,
          bollinger: bollinger,
          supportResistance: supportResistance
        },
        
        // Signaux
        signals: signals,
        
        // Score et recommandation
        tradingScore: Math.round(tradingScore),
        recommendation: recommendation,
        
        // M√©tadonn√©es
        analysisTimestamp: new Date().toISOString(),
        analysisType: "TECHNICAL_COMPLETE"
      };
      
    } catch (error) {
      console.error(\`‚ùå Analysis error for \${token.symbol}:\`, error);
      
      return {
        ...token,
        tradingScore: 50,
        recommendation: "HOLD",
        error: error.message,
        analysisTimestamp: new Date().toISOString()
      };
    }
  });
  
  // ===== FILTRAGE DES OPPORTUNIT√âS =====
  const opportunities = analyzedTokens.filter(token => {
    return token.tradingScore >= 65 && // Score minimum
           token.recommendation !== "HOLD" &&
           token.volume24h > 10000000 && // Volume minimum 10M
           token.marketCap > 100000000; // Market cap minimum 100M
  });
  
  // Trier par score d√©croissant
  opportunities.sort((a, b) => b.tradingScore - a.tradingScore);
  
  console.log(\`‚úÖ Technical Analysis completed:\`);
  console.log(\`- \${analyzedTokens.length} tokens analyzed\`);
  console.log(\`- \${opportunities.length} opportunities found\`);
  console.log("üéØ Top opportunities:", opportunities.slice(0, 3).map(t => \`\${t.symbol}: \${t.tradingScore}/100 (\${t.recommendation})\`));
  
  return [{
    json: {
      allTokens: analyzedTokens,
      opportunities: opportunities,
      totalAnalyzed: analyzedTokens.length,
      totalOpportunities: opportunities.length,
      analysisTimestamp: new Date().toISOString(),
      analysisType: "TECHNICAL_ANALYSIS"
    }
  }];
  `
    }
  };
  
  export { triggerNode, establishedScannerNode, technicalAnalysisNode };