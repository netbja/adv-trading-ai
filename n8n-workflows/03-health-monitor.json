// 🔍 WORKFLOW 3: HEALTH MONITOR IA
// Fichier: n8n-workflows/03-health-monitor.json

/*
ARCHITECTURE:
⏰ Cron (30s) → 🔍 Network Health → 🧠 IA Analysis → 🎯 Decision → 📊 Feedback Loop
                       ↓                 ↓              ↓
                API/RPC Tests → Health Score → Auto-Adjustment
*/

// ===== NODE 1: HEALTH MONITOR TRIGGER =====
const healthTriggerNode = {
    name: "⏰ Health Monitor (30s)",
    type: "n8n-nodes-base.cron",
    position: [20, 20],
    parameters: {
      rule: {
        second: "*/30", // Toutes les 30 secondes
        timezone: "Europe/Paris"
      }
    }
  };
  
  // ===== NODE 2: NETWORK & API HEALTH CHECKER =====
  const networkHealthNode = {
    name: "🔍 Network & API Health Checker",
    type: "n8n-nodes-base.code",
    position: [240, 20],
    parameters: {
      mode: "runOnceForAllItems",
      jsCode: `
  // 🔍 NETWORK & API HEALTH COMPREHENSIVE CHECKER
  console.log("🔍 Starting comprehensive health check...");
  
  // ===== CONFIGURATION DES SERVICES À TESTER =====
  const SERVICES_TO_TEST = {
    // APIs Crypto principales
    cryptoAPIs: [
      { name: "CoinGecko", url: "https://api.coingecko.com/api/v3/ping", timeout: 5000, critical: true },
      { name: "CoinMarketCap", url: "https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest", timeout: 5000, critical: false },
      { name: "Binance", url: "https://api.binance.com/api/v3/ping", timeout: 3000, critical: true },
      { name: "Coinbase", url: "https://api.coinbase.com/v2/time", timeout: 5000, critical: false }
    ],
    
    // RPCs Blockchain
    blockchainRPCs: [
      { name: "Ethereum-Infura", url: "https://mainnet.infura.io/v3/YOUR_KEY", timeout: 10000, critical: true },
      { name: "Polygon-RPC", url: "https://polygon-rpc.com/", timeout: 8000, critical: true },
      { name: "BSC-RPC", url: "https://bsc-dataseed.binance.org/", timeout: 8000, critical: false },
      { name: "Solana-RPC", url: "https://api.mainnet-beta.solana.com", timeout: 8000, critical: false }
    ],
    
    // Services IA
    aiServices: [
      { name: "Groq", url: "https://api.groq.com/openai/v1/models", timeout: 10000, critical: true },
      { name: "OpenAI", url: "https://api.openai.com/v1/models", timeout: 10000, critical: false },
      { name: "Anthropic", url: "https://api.anthropic.com/v1/messages", timeout: 10000, critical: false }
    ],
    
    // Services externes
    externalServices: [
      { name: "Telegram", url: "https://api.telegram.org/bot", timeout: 5000, critical: true },
      { name: "Discord", url: "https://discord.com/api/v10/gateway", timeout: 5000, critical: false },
      { name: "News-API", url: "https://newsapi.org/v2/everything", timeout: 8000, critical: false }
    ]
  };
  
  // ===== FONCTIONS DE TEST =====
  
  // Test de latence réseau
  async function testLatency(url, timeout = 5000) {
    const startTime = performance.now();
    
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      const response = await fetch(url, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          'User-Agent': 'TradingAI-HealthMonitor/1.0'
        }
      });
      
      clearTimeout(timeoutId);
      const endTime = performance.now();
      const latency = Math.round(endTime - startTime);
      
      return {
        status: response.ok ? 'UP' : 'DEGRADED',
        latency: latency,
        statusCode: response.status,
        error: null
      };
      
    } catch (error) {
      const endTime = performance.now();
      const latency = Math.round(endTime - startTime);
      
      return {
        status: 'DOWN',
        latency: latency,
        statusCode: 0,
        error: error.message
      };
    }
  }
  
  // Test spécialisé RPC
  async function testRPC(rpcUrl, timeout = 10000) {
    try {
      const rpcPayload = {
        jsonrpc: "2.0",
        method: "eth_blockNumber", // Test standard pour ETH-compatible
        params: [],
        id: 1
      };
      
      const startTime = performance.now();
      const response = await fetch(rpcUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(rpcPayload),
        signal: AbortSignal.timeout(timeout)
      });
      
      const endTime = performance.now();
      const latency = Math.round(endTime - startTime);
      
      const data = await response.json();
      
      return {
        status: data.result ? 'UP' : 'DEGRADED',
        latency: latency,
        blockNumber: data.result,
        error: data.error || null
      };
      
    } catch (error) {
      return {
        status: 'DOWN',
        latency: timeout,
        error: error.message
      };
    }
  }
  
  // ===== EXÉCUTION DES TESTS =====
  const healthResults = {
    timestamp: new Date().toISOString(),
    summary: {
      totalServices: 0,
      servicesUp: 0,
      servicesDown: 0,
      criticalDown: 0,
      avgLatency: 0
    },
    details: {}
  };
  
  let totalLatency = 0;
  let serviceCount = 0;
  
  // Test des APIs Crypto
  console.log("🔄 Testing Crypto APIs...");
  healthResults.details.cryptoAPIs = [];
  
  for (const api of SERVICES_TO_TEST.cryptoAPIs) {
    const result = await testLatency(api.url, api.timeout);
    
    const serviceResult = {
      name: api.name,
      status: result.status,
      latency: result.latency,
      critical: api.critical,
      statusCode: result.statusCode,
      error: result.error,
      timestamp: new Date().toISOString()
    };
    
    healthResults.details.cryptoAPIs.push(serviceResult);
    
    if (result.status === 'UP') healthResults.summary.servicesUp++;
    else healthResults.summary.servicesDown++;
    
    if (result.status === 'DOWN' && api.critical) {
      healthResults.summary.criticalDown++;
    }
    
    totalLatency += result.latency;
    serviceCount++;
    
    console.log(\`\${api.name}: \${result.status} (\${result.latency}ms)\`);
  }
  
  // Test des RPCs Blockchain
  console.log("🔄 Testing Blockchain RPCs...");
  healthResults.details.blockchainRPCs = [];
  
  for (const rpc of SERVICES_TO_TEST.blockchainRPCs) {
    const result = await testRPC(rpc.url, rpc.timeout);
    
    const serviceResult = {
      name: rpc.name,
      status: result.status,
      latency: result.latency,
      critical: rpc.critical,
      blockNumber: result.blockNumber,
      error: result.error,
      timestamp: new Date().toISOString()
    };
    
    healthResults.details.blockchainRPCs.push(serviceResult);
    
    if (result.status === 'UP') healthResults.summary.servicesUp++;
    else healthResults.summary.servicesDown++;
    
    if (result.status === 'DOWN' && rpc.critical) {
      healthResults.summary.criticalDown++;
    }
    
    totalLatency += result.latency;
    serviceCount++;
    
    console.log(\`\${rpc.name}: \${result.status} (\${result.latency}ms)\`);
  }
  
  // Test des Services IA (simplifié)
  console.log("🔄 Testing AI Services...");
  healthResults.details.aiServices = [];
  
  for (const ai of SERVICES_TO_TEST.aiServices) {
    // Test simplifié sans API key
    const result = await testLatency(ai.url.replace('/models', ''), ai.timeout);
    
    const serviceResult = {
      name: ai.name,
      status: result.statusCode === 401 ? 'UP' : result.status, // 401 = service up but need auth
      latency: result.latency,
      critical: ai.critical,
      statusCode: result.statusCode,
      needsAuth: result.statusCode === 401,
      error: result.statusCode === 401 ? null : result.error,
      timestamp: new Date().toISOString()
    };
    
    healthResults.details.aiServices.push(serviceResult);
    
    if (serviceResult.status === 'UP') healthResults.summary.servicesUp++;
    else healthResults.summary.servicesDown++;
    
    if (serviceResult.status === 'DOWN' && ai.critical) {
      healthResults.summary.criticalDown++;
    }
    
    totalLatency += result.latency;
    serviceCount++;
    
    console.log(\`\${ai.name}: \${serviceResult.status} (\${result.latency}ms)\`);
  }
  
  // ===== CALCUL DU SCORE DE SANTÉ GLOBAL =====
  healthResults.summary.totalServices = serviceCount;
  healthResults.summary.avgLatency = Math.round(totalLatency / serviceCount);
  
  // Score de santé (0-100)
  let healthScore = 100;
  
  // Pénalités
  const downServicesPenalty = (healthResults.summary.servicesDown / serviceCount) * 50;
  const criticalDownPenalty = healthResults.summary.criticalDown * 20;
  const latencyPenalty = Math.max(0, (healthResults.summary.avgLatency - 1000) / 100); // Pénalité si >1s
  
  healthScore -= downServicesPenalty + criticalDownPenalty + latencyPenalty;
  healthScore = Math.max(0, Math.min(100, Math.round(healthScore)));
  
  healthResults.summary.healthScore =