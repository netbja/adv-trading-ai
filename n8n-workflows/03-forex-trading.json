// 💱 WORKFLOW 3: FOREX TRADING - ENHANCED SESSION-BASED STRATEGY
// Fichier: n8n-workflows/03-forex-trading.json

/*
WORKFLOW STRUCTURE:
⏰ Webhook → 🌍 Session Detector → 📊 Forex Scanner → 🔍 Technical Analysis → 📈 Decision → 💱 Execute
                        ↓                        ↓                  ↓                 ↓
           TraderMade API → Major Pairs Filter → RSI/MACD/Bollinger → Position Manager
                        ↓                        ↓                  ↓                 ↓
              📊 Volatility Check → 🧠 Shared Brain ← Performance Tracker ← Portfolio Update
*/

{
  "name": "💱 Enhanced Forex Trading System",
  "nodes": [
    
    // ===== NODE 1: WEBHOOK TRIGGER =====
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "forex-enhanced-trading",
        "options": {}
      },
      "name": "💱 Forex Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [20, 20],
      "webhookId": "forex-enhanced-trading"
    },

    // ===== NODE 2: SESSION DETECTOR & CONFIG =====
    {
      "parameters": {
        "functionCode": `
// 🌍 FOREX SESSION DETECTOR & CONFIGURATION
console.log("🌍 Enhanced Forex Session Detector starting...");

// Enhanced Forex Configuration (from Python enhanced bridge)
const FOREX_CONFIG = {
  sessions: {
    LONDON: {
      hours: "07:00-16:00",
      pairs: ["EURUSD", "GBPUSD", "EURGBP", "EURJPY"],
      volatility: "HIGH",
      overlap: null,
      description: "European markets active, high EUR/GBP volatility"
    },
    NEW_YORK: {
      hours: "13:00-22:00", 
      pairs: ["EURUSD", "GBPUSD", "USDJPY", "USDCAD"],
      volatility: "VERY_HIGH",
      overlap: "LONDON",
      description: "US markets + London overlap, highest liquidity"
    },
    ASIA: {
      hours: "21:00-06:00",
      pairs: ["USDJPY", "AUDUSD", "NZDUSD", "EURJPY"],
      volatility: "MEDIUM",
      overlap: null,
      description: "Asian markets, JPY focus, lower volatility"
    },
    QUIET: {
      hours: "other",
      pairs: [],
      volatility: "LOW",
      overlap: null,
      description: "Market gaps between major sessions"
    }
  },
  
  risk_management: {
    max_position_size: 0.02,  // 2% per position
    max_total_exposure: 0.10,  // 10% total forex
    stop_loss: 0.008,  // 0.8% stop loss
    take_profit: [0.012, 0.02, 0.035],  // 1.2%, 2%, 3.5%
    correlation_limit: 0.7  // Max correlation between pairs
  },
  
  technical_indicators: {
    rsi: { period: 14, oversold: 30, overbought: 70 },
    macd: { fast: 12, slow: 26, signal: 9 },
    bollinger: { period: 20, stdDev: 2 },
    ema: { periods: [9, 21, 50] }
  }
};

// Detect current session
function detectCurrentSession() {
  const now = new Date();
  const utcHour = now.getUTCHours();
  
  console.log(\`🕐 Current UTC time: \${utcHour}:00\`);
  
  if (utcHour >= 7 && utcHour < 16) {
    return {
      session: "LONDON",
      config: FOREX_CONFIG.sessions.LONDON,
      strength: utcHour >= 8 && utcHour <= 15 ? "PEAK" : "NORMAL"
    };
  } else if (utcHour >= 13 && utcHour < 22) {
    return {
      session: "NEW_YORK",
      config: FOREX_CONFIG.sessions.NEW_YORK,
      strength: utcHour >= 14 && utcHour <= 17 ? "PEAK" : "NORMAL",
      london_overlap: utcHour >= 13 && utcHour < 16
    };
  } else if (utcHour >= 21 || utcHour < 6) {
    return {
      session: "ASIA",
      config: FOREX_CONFIG.sessions.ASIA,
      strength: (utcHour >= 22 && utcHour <= 23) || (utcHour >= 1 && utcHour <= 4) ? "PEAK" : "NORMAL"
    };
  } else {
    return {
      session: "QUIET",
      config: FOREX_CONFIG.sessions.QUIET,
      strength: "MINIMAL"
    };
  }
}

// Get webhook data
const webhookData = $input.all()[0].json;
const sessionInfo = detectCurrentSession();

// Enhanced session analysis
const sessionAnalysis = {
  ...sessionInfo,
  utc_hour: new Date().getUTCHours(),
  market_open: sessionInfo.session !== "QUIET",
  recommended_pairs: sessionInfo.config.pairs,
  expected_volatility: sessionInfo.config.volatility,
  overlap_session: sessionInfo.config.overlap,
  london_overlap: sessionInfo.london_overlap || false,
  
  // AI Orchestrator context
  orchestrator_data: {
    allocation_percentage: webhookData.parameters?.allocation_percentage || 0.33,
    session_config: webhookData.parameters?.session_config || {},
    risk_config: webhookData.parameters?.risk_config || FOREX_CONFIG.risk_management,
    market_context: webhookData.market_context || {}
  },
  
  // Risk parameters
  risk_parameters: {
    position_size_multiplier: sessionInfo.strength === "PEAK" ? 1.2 : 1.0,
    volatility_filter: sessionInfo.config.volatility,
    max_positions: sessionInfo.session === "NEW_YORK" ? 5 : 3
  }
};

console.log("🌍 Session Analysis:", {
  session: sessionAnalysis.session,
  strength: sessionAnalysis.strength,
  pairs: sessionAnalysis.recommended_pairs.length,
  volatility: sessionAnalysis.expected_volatility,
  allocation: sessionAnalysis.orchestrator_data.allocation_percentage
});

return [{
  json: {
    session_analysis: sessionAnalysis,
    forex_config: FOREX_CONFIG,
    timestamp: new Date().toISOString(),
    workflow_type: "forex_enhanced"
  }
}];`
      },
      "name": "🌍 Session Detector",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [220, 20]
    },

    // ===== NODE 3: FOREX DATA SCANNER =====
    {
      "parameters": {
        "functionCode": `
// 💱 ENHANCED FOREX DATA SCANNER
console.log("💱 Starting Enhanced Forex Data Scanner...");

const sessionData = $json.session_analysis;
const forexConfig = $json.forex_config;

// Skip if quiet session
if (sessionData.session === "QUIET") {
  console.log("🌙 Quiet session detected - minimal forex activity");
  return [{
    json: {
      session: "QUIET",
      pairs_data: [],
      scan_result: "skipped",
      reason: "Market closed or minimal activity",
      timestamp: new Date().toISOString()
    }
  }];
}

// TraderMade API configuration
const TRADERMADE_CONFIG = {
  base_url: "https://marketdata.tradermade.com/api/v1",
  api_key: process.env.TRADERMADE_API_KEY || "demo",
  live_endpoint: "/live",
  historical_endpoint: "/timeseries"
};

// Currency pairs to scan (based on session)
const pairsToScan = sessionData.recommended_pairs;
console.log(\`📊 Scanning \${pairsToScan.length} pairs for \${sessionData.session} session\`);

// Simulate API calls (replace with real TraderMade calls)
async function fetchForexData() {
  // In production, make real API calls to TraderMade
  const mockData = pairsToScan.map(pair => {
    const baseRate = pair === "EURUSD" ? 1.0850 : 
                    pair === "GBPUSD" ? 1.2720 :
                    pair === "USDJPY" ? 149.50 :
                    pair === "AUDUSD" ? 0.6580 : 1.0000;
    
    // Simulate realistic forex movements
    const volatility = sessionData.expected_volatility === "VERY_HIGH" ? 0.008 :
                      sessionData.expected_volatility === "HIGH" ? 0.005 :
                      sessionData.expected_volatility === "MEDIUM" ? 0.003 : 0.001;
    
    const priceChange = (Math.random() - 0.5) * volatility;
    const currentRate = baseRate + priceChange;
    
    return {
      pair: pair,
      base_currency: pair.substr(0, 3),
      quote_currency: pair.substr(3, 3),
      current_rate: parseFloat(currentRate.toFixed(5)),
      change_24h: priceChange,
      change_24h_pct: parseFloat((priceChange / baseRate * 100).toFixed(3)),
      bid: currentRate - 0.0001,
      ask: currentRate + 0.0001,
      spread: 0.0002,
      
      // Session-specific data
      session_volatility: sessionData.expected_volatility,
      session_strength: sessionData.strength,
      london_overlap: sessionData.london_overlap || false,
      
      // Technical indicators (simplified)
      technical: {
        rsi: 50 + (Math.random() - 0.5) * 40, // 30-70 range
        trend: Math.abs(priceChange) > volatility * 0.5 ? 
               (priceChange > 0 ? "BULLISH" : "BEARISH") : "SIDEWAYS",
        momentum: Math.abs(priceChange) > volatility * 0.7 ? "STRONG" : "WEAK"
      },
      
      // Risk metrics
      correlation_score: Math.random() * 0.8, // Correlation with other pairs
      liquidity_score: pair.includes("USD") ? 1.0 : 0.8,
      volatility_score: Math.abs(priceChange) / volatility,
      
      timestamp: new Date().toISOString()
    };
  });
  
  return mockData;
}

const forexData = await fetchForexData();

// Filter pairs based on criteria
const filteredPairs = forexData.filter(pair => {
  // Basic filters
  if (Math.abs(pair.change_24h_pct) < 0.1) return false; // Minimum movement
  if (pair.spread > 0.0005) return false; // Maximum spread
  
  // Session-specific filters
  if (sessionData.session === "ASIA" && !pair.pair.includes("JPY") && !pair.pair.includes("AUD")) {
    return Math.abs(pair.change_24h_pct) > 0.2; // Higher threshold for non-Asian pairs
  }
  
  return true;
});

console.log(\`✅ Filtered to \${filteredPairs.length} tradeable pairs\`);

// Calculate session score
const sessionScore = {
  total_pairs: forexData.length,
  tradeable_pairs: filteredPairs.length,
  avg_volatility: forexData.reduce((sum, p) => sum + Math.abs(p.change_24h_pct), 0) / forexData.length,
  session_strength: sessionData.strength,
  market_sentiment: filteredPairs.length > pairsToScan.length * 0.6 ? "POSITIVE" : "NEUTRAL"
};

return [{
  json: {
    session: sessionData.session,
    session_score: sessionScore,
    pairs_data: filteredPairs,
    all_pairs: forexData,
    scan_timestamp: new Date().toISOString(),
    workflow_step: "forex_scan_complete"
  }
}];`
      },
      "name": "💱 Forex Scanner",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [420, 20]
    },

    // ===== NODE 4: TECHNICAL ANALYSIS ENGINE =====
    {
      "parameters": {
        "functionCode": `
// 📊 ADVANCED FOREX TECHNICAL ANALYSIS
console.log("📊 Starting Advanced Forex Technical Analysis...");

const scanData = $json;
const forexConfig = $input.first().json.forex_config;

if (scanData.session === "QUIET" || !scanData.pairs_data.length) {
  console.log("⏰ No pairs to analyze or quiet session");
  return [{
    json: {
      session: scanData.session,
      analysis_result: "skipped",
      analyzed_pairs: [],
      recommendations: [],
      timestamp: new Date().toISOString()
    }
  }];
}

// Advanced Technical Analysis Functions (from JS workflows)
function calculateRSI(prices, period = 14) {
  if (prices.length < period + 1) return 50; // Neutral if insufficient data
  
  let gains = 0, losses = 0;
  
  for (let i = 1; i <= period; i++) {
    const change = prices[i] - prices[i - 1];
    if (change > 0) gains += change;
    else losses += Math.abs(change);
  }
  
  const avgGain = gains / period;
  const avgLoss = losses / period;
  
  if (avgLoss === 0) return 100;
  
  const RS = avgGain / avgLoss;
  const RSI = 100 - (100 / (1 + RS));
  
  return Math.round(RSI * 100) / 100;
}

function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  if (prices.length < slowPeriod) return { macd: 0, signal: 0, histogram: 0 };
  
  // Simplified EMA calculation
  function calculateEMA(prices, period) {
    const multiplier = 2 / (period + 1);
    let ema = prices[0];
    
    for (let i = 1; i < prices.length; i++) {
      ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
    }
    return ema;
  }
  
  const fastEMA = calculateEMA(prices, fastPeriod);
  const slowEMA = calculateEMA(prices, slowPeriod);
  const macd = fastEMA - slowEMA;
  
  // Simplified signal line
  const signal = macd * 0.8; // Approximation
  const histogram = macd - signal;
  
  return {
    macd: Math.round(macd * 100000) / 100000,
    signal: Math.round(signal * 100000) / 100000,
    histogram: Math.round(histogram * 100000) / 100000
  };
}

function calculateForexTechnicalScore(pairData) {
  let score = 50; // Base neutral score
  
  // RSI Analysis
  const rsi = pairData.technical.rsi;
  if (rsi < 30) score += 20; // Oversold - bullish
  else if (rsi > 70) score -= 15; // Overbought - bearish
  else if (rsi >= 45 && rsi <= 55) score += 5; // Neutral momentum
  
  // Volatility Analysis
  const volatilityScore = pairData.volatility_score;
  if (volatilityScore > 0.8) score += 15; // High volatility opportunity
  else if (volatilityScore < 0.3) score -= 10; // Too low volatility
  
  // Session Strength
  if (pairData.session_strength === "PEAK") score += 10;
  else if (pairData.session_strength === "MINIMAL") score -= 15;
  
  // London-NY Overlap Bonus
  if (pairData.london_overlap) score += 12;
  
  // Trend Analysis
  if (pairData.technical.trend === "BULLISH" && pairData.technical.momentum === "STRONG") {
    score += 18;
  } else if (pairData.technical.trend === "BEARISH" && pairData.technical.momentum === "STRONG") {
    score -= 12; // Bearish but could be reversal opportunity
  }
  
  // Liquidity Bonus
  score += pairData.liquidity_score * 5;
  
  // Spread Penalty
  if (pairData.spread > 0.0003) score -= 8;
  
  return Math.max(0, Math.min(100, score));
}

// Analyze each pair
const analyzedPairs = scanData.pairs_data.map(pair => {
  // Generate synthetic price history for technical analysis
  const currentRate = pair.current_rate;
  const volatility = 0.001; // Daily volatility estimate
  const priceHistory = [];
  
  // Generate 26 periods for MACD calculation
  for (let i = 0; i < 26; i++) {
    const randomChange = (Math.random() - 0.5) * volatility;
    const price = currentRate + (randomChange * (26 - i) / 26);
    priceHistory.push(price);
  }
  priceHistory.push(currentRate); // Current price
  
  // Calculate technical indicators
  const rsi = calculateRSI(priceHistory);
  const macd = calculateMACD(priceHistory);
  
  // Enhanced technical analysis
  const technicalAnalysis = {
    rsi: rsi,
    macd: macd,
    trend_strength: Math.abs(pair.change_24h_pct) > 0.3 ? "STRONG" : "WEAK",
    momentum: pair.technical.momentum,
    
    // Forex-specific indicators
    currency_strength: {
      base: pair.base_currency === "USD" ? "STRONG" : "MEDIUM",
      quote: pair.quote_currency === "USD" ? "STRONG" : "MEDIUM"
    },
    
    // Session analysis
    session_optimal: scanData.session_score.session_strength === "PEAK",
    volatility_level: pair.session_volatility,
    
    // Risk assessment
    risk_level: pair.volatility_score > 0.8 ? "HIGH" : 
               pair.volatility_score > 0.5 ? "MEDIUM" : "LOW"
  };
  
  // Calculate comprehensive technical score
  const technicalScore = calculateForexTechnicalScore(pair);
  
  // Generate trading signals
  const signals = {
    entry: [],
    exit: [],
    strength: 0
  };
  
  if (rsi < 30 && macd.histogram > 0) {
    signals.entry.push({
      type: "RSI_MACD_BULLISH",
      strength: 3,
      description: "RSI oversold with MACD bullish divergence"
    });
  }
  
  if (pair.london_overlap && technicalScore > 65) {
    signals.entry.push({
      type: "LONDON_NY_OVERLAP",
      strength: 2,
      description: "High-probability setup during London-NY overlap"
    });
  }
  
  if (technicalScore > 70 && pair.liquidity_score > 0.9) {
    signals.entry.push({
      type: "HIGH_CONVICTION",
      strength: 4,
      description: "Strong technical setup with high liquidity"
    });
  }
  
  signals.strength = signals.entry.reduce((sum, signal) => sum + signal.strength, 0);
  
  return {
    ...pair,
    technical_analysis: technicalAnalysis,
    technical_score: technicalScore,
    signals: signals,
    recommendation: {
      action: technicalScore > 70 ? "STRONG_BUY" :
              technicalScore > 60 ? "BUY" :
              technicalScore < 30 ? "AVOID" : "HOLD",
      confidence: Math.round(technicalScore),
      position_size: Math.min(0.02, technicalScore / 100 * 0.03), // Max 2% or based on score
      stop_loss: pair.current_rate * (1 - forexConfig.risk_management.stop_loss),
      take_profits: forexConfig.risk_management.take_profit.map(tp => 
        pair.current_rate * (1 + tp)
      ),
      holding_period: "4-8 hours", // Typical forex session
      reasoning: \`Technical score: \${technicalScore}/100, Session: \${scanData.session}, RSI: \${rsi.toFixed(1)}\`
    }
  };
});

// Sort by technical score
analyzedPairs.sort((a, b) => b.technical_score - a.technical_score);

// Generate recommendations
const recommendations = analyzedPairs
  .filter(pair => pair.technical_score > 55)
  .slice(0, 3) // Top 3 opportunities
  .map(pair => ({
    pair: pair.pair,
    action: pair.recommendation.action,
    score: pair.technical_score,
    confidence: pair.recommendation.confidence,
    entry_rate: pair.current_rate,
    stop_loss: pair.recommendation.stop_loss,
    take_profits: pair.recommendation.take_profits,
    position_size: pair.recommendation.position_size,
    reasoning: pair.recommendation.reasoning,
    session: scanData.session,
    signals: pair.signals.entry.map(s => s.type)
  }));

console.log(\`📊 Analysis complete: \${analyzedPairs.length} pairs analyzed, \${recommendations.length} recommendations\`);

return [{
  json: {
    session: scanData.session,
    analysis_result: "complete",
    total_analyzed: analyzedPairs.length,
    analyzed_pairs: analyzedPairs,
    recommendations: recommendations,
    session_summary: {
      avg_technical_score: analyzedPairs.reduce((sum, p) => sum + p.technical_score, 0) / analyzedPairs.length,
      high_conviction_trades: recommendations.filter(r => r.confidence > 70).length,
      session_strength: scanData.session_score.session_strength,
      market_sentiment: scanData.session_score.market_sentiment
    },
    analysis_timestamp: new Date().toISOString(),
    workflow_step: "technical_analysis_complete"
  }
}];`
      },
      "name": "📊 Technical Analysis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [620, 20]
    },

    // ===== NODE 5: FOREX DECISION ENGINE =====
    {
      "parameters": {
        "functionCode": `
// 🎯 FOREX TRADING DECISION ENGINE
console.log("🎯 Starting Forex Trading Decision Engine...");

const analysisData = $json;

if (analysisData.session === "QUIET" || !analysisData.recommendations.length) {
  console.log("⏰ No recommendations or quiet session - no trades");
  return [{
    json: {
      decision: "SKIP",
      session: analysisData.session || "QUIET",
      reason: "No viable trading opportunities or market closed",
      trades: [],
      portfolio_impact: { positions: 0, allocation: 0 },
      timestamp: new Date().toISOString()
    }
  }];
}

// Trading decision logic (enhanced from JS workflows)
const DECISION_CONFIG = {
  min_confidence: 60,
  max_positions: analysisData.session === "NEW_YORK" ? 5 : 3,
  max_correlation: 0.7,
  min_session_strength: "NORMAL"
};

// Filter recommendations by confidence
const viableRecommendations = analysisData.recommendations.filter(rec => 
  rec.confidence >= DECISION_CONFIG.min_confidence &&
  rec.action !== "AVOID"
);

if (!viableRecommendations.length) {
  console.log("📊 No recommendations meet confidence threshold");
  return [{
    json: {
      decision: "WAIT",
      session: analysisData.session,
      reason: \`No recommendations above \${DECISION_CONFIG.min_confidence}% confidence\`,
      trades: [],
      portfolio_impact: { positions: 0, allocation: 0 },
      timestamp: new Date().toISOString()
    }
  }];
}

// Select best opportunities (avoiding high correlation)
const selectedTrades = [];
const maxTrades = Math.min(DECISION_CONFIG.max_positions, viableRecommendations.length);

for (const recommendation of viableRecommendations) {
  if (selectedTrades.length >= maxTrades) break;
  
  // Check correlation with existing selections
  const hasHighCorrelation = selectedTrades.some(trade => {
    const curr1 = recommendation.pair.substr(0, 3);
    const curr2 = recommendation.pair.substr(3, 3);
    const tradeCurr1 = trade.pair.substr(0, 3);
    const tradeCurr2 = trade.pair.substr(3, 3);
    
    // Simple correlation check - same currencies
    return curr1 === tradeCurr1 || curr1 === tradeCurr2 || 
           curr2 === tradeCurr1 || curr2 === tradeCurr2;
  });
  
  if (!hasHighCorrelation) {
    // Create trade execution plan
    const trade = {
      id: \`forex_\${Date.now()}_\${selectedTrades.length}\`,
      pair: recommendation.pair,
      action: "BUY", // Simplified - could be BUY/SELL based on analysis
      entry_rate: recommendation.entry_rate,
      position_size_usd: recommendation.position_size * 10000, // Assuming $10k allocation per %
      position_size_pct: recommendation.position_size,
      
      // Risk management
      stop_loss: recommendation.stop_loss,
      take_profits: recommendation.take_profits,
      risk_reward_ratio: (recommendation.take_profits[0] - recommendation.entry_rate) / 
                        (recommendation.entry_rate - recommendation.stop_loss),
      
      // Trade metadata
      strategy: "forex_sessions",
      session: analysisData.session,
      confidence: recommendation.confidence,
      technical_score: recommendation.score,
      signals: recommendation.signals,
      reasoning: recommendation.reasoning,
      
      // Execution timing
      created_at: new Date().toISOString(),
      session_strength: analysisData.session_summary.session_strength,
      london_overlap: analysisData.session === "NEW_YORK", // Simplified
      
      // Expected metrics
      expected_duration: "4-8 hours",
      expected_roi: ((recommendation.take_profits[0] - recommendation.entry_rate) / recommendation.entry_rate) * 100
    };
    
    selectedTrades.push(trade);
  }
}

// Calculate portfolio impact
const totalAllocation = selectedTrades.reduce((sum, trade) => sum + trade.position_size_pct, 0);
const portfolioImpact = {
  new_positions: selectedTrades.length,
  total_allocation: totalAllocation,
  avg_confidence: selectedTrades.reduce((sum, trade) => sum + trade.confidence, 0) / selectedTrades.length,
  risk_level: totalAllocation > 0.06 ? "HIGH" : totalAllocation > 0.03 ? "MEDIUM" : "LOW",
  session: analysisData.session,
  expected_roi: selectedTrades.reduce((sum, trade) => sum + trade.expected_roi, 0) / selectedTrades.length
};

// Final decision
const decision = selectedTrades.length > 0 ? "EXECUTE" : "WAIT";
const decisionReason = selectedTrades.length > 0 ? 
  \`Execute \${selectedTrades.length} forex trades in \${analysisData.session} session\` :
  "No uncorrelated opportunities found";

console.log(\`🎯 Decision: \${decision} - \${selectedTrades.length} trades planned\`);

return [{
  json: {
    decision: decision,
    session: analysisData.session,
    reason: decisionReason,
    trades: selectedTrades,
    portfolio_impact: portfolioImpact,
    session_summary: analysisData.session_summary,
    
    // Execution metadata
    decision_timestamp: new Date().toISOString(),
    workflow_step: "forex_decision_complete",
    total_recommendations: analysisData.recommendations.length,
    viable_recommendations: viableRecommendations.length,
    correlation_filtering: true
  }
}];`
      },
      "name": "🎯 Decision Engine",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [820, 20]
    },

    // ===== NODE 6: TRADE EXECUTOR =====
    {
      "parameters": {
        "functionCode": `
// 💱 FOREX TRADE EXECUTOR
console.log("💱 Starting Forex Trade Executor...");

const decisionData = $json;

if (decisionData.decision !== "EXECUTE" || !decisionData.trades.length) {
  console.log(\`⏰ Decision: \${decisionData.decision} - No trades to execute\`);
  return [{
    json: {
      execution_result: "SKIPPED",
      session: decisionData.session,
      reason: decisionData.reason,
      executed_trades: [],
      portfolio_update: { success: true, changes: [] },
      timestamp: new Date().toISOString()
    }
  }];
}

// Simulate trade execution (replace with real broker API)
console.log(\`💱 Executing \${decisionData.trades.length} forex trades...\`);

const executedTrades = [];
const executionErrors = [];

for (const trade of decisionData.trades) {
  try {
    // Simulate execution delay and slippage
    const executionDelay = Math.random() * 2000; // 0-2 seconds
    await new Promise(resolve => setTimeout(resolve, executionDelay));
    
    // Simulate slippage (typical for forex: 0.1-0.5 pips)
    const slippagePips = (Math.random() - 0.5) * 0.0003; // ±0.3 pips
    const executedRate = trade.entry_rate + slippagePips;
    
    // Simulate execution success rate (95% for major pairs)
    const executionSuccess = Math.random() > 0.05;
    
    if (executionSuccess) {
      const executedTrade = {
        ...trade,
        status: "EXECUTED",
        executed_rate: executedRate,
        slippage_pips: Math.abs(slippagePips * 10000), // Convert to pips
        execution_time: executionDelay,
        executed_at: new Date().toISOString(),
        
        // Update stop loss and take profits based on executed rate
        adjusted_stop_loss: executedRate * (1 - 0.008), // 0.8% stop
        adjusted_take_profits: [
          executedRate * (1 + 0.012), // 1.2% TP1
          executedRate * (1 + 0.02),  // 2% TP2
          executedRate * (1 + 0.035)  // 3.5% TP3
        ],
        
        // Execution metadata
        execution_id: \`fx_exec_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`,
        broker: "simulated",
        commission: trade.position_size_usd * 0.0001, // 0.01% commission
        swap: 0 // Overnight interest (if held overnight)
      };
      
      executedTrades.push(executedTrade);
      console.log(\`✅ \${trade.pair}: Executed at \${executedRate.toFixed(5)} (slippage: \${executedTrade.slippage_pips.toFixed(1)} pips)\`);
    } else {
      executionErrors.push({
        trade_id: trade.id,
        pair: trade.pair,
        error: "Execution rejected by broker",
        timestamp: new Date().toISOString()
      });
      console.log(\`❌ \${trade.pair}: Execution failed\`);
    }
    
  } catch (error) {
    executionErrors.push({
      trade_id: trade.id,
      pair: trade.pair,
      error: error.message,
      timestamp: new Date().toISOString()
    });
    console.log(\`❌ \${trade.pair}: Execution error - \${error.message}\`);
  }
}

// Update portfolio
const portfolioUpdate = {
  success: true,
  new_positions: executedTrades.length,
  failed_executions: executionErrors.length,
  total_allocation: executedTrades.reduce((sum, trade) => sum + trade.position_size_pct, 0),
  total_commission: executedTrades.reduce((sum, trade) => sum + trade.commission, 0),
  changes: executedTrades.map(trade => ({
    pair: trade.pair,
    action: trade.action,
    size: trade.position_size_pct,
    rate: trade.executed_rate
  }))
};

// Send to shared brain / performance tracker
const performanceData = {
  strategy: "forex_sessions",
  session: decisionData.session,
  total_planned: decisionData.trades.length,
  total_executed: executedTrades.length,
  execution_rate: executedTrades.length / decisionData.trades.length,
  avg_slippage: executedTrades.reduce((sum, trade) => sum + trade.slippage_pips, 0) / executedTrades.length,
  avg_confidence: executedTrades.reduce((sum, trade) => sum + trade.confidence, 0) / executedTrades.length,
  session_strength: decisionData.session_summary?.session_strength || "UNKNOWN"
};

console.log(\`💱 Execution complete: \${executedTrades.length}/\${decisionData.trades.length} trades executed\`);

return [{
  json: {
    execution_result: "COMPLETE",
    session: decisionData.session,
    executed_trades: executedTrades,
    execution_errors: executionErrors,
    portfolio_update: portfolioUpdate,
    performance_data: performanceData,
    
    // Summary metrics
    summary: {
      total_planned: decisionData.trades.length,
      total_executed: executedTrades.length,
      execution_success_rate: (executedTrades.length / decisionData.trades.length) * 100,
      total_position_size: portfolioUpdate.total_allocation,
      avg_slippage_pips: performanceData.avg_slippage || 0,
      session_strength: decisionData.session_summary?.session_strength || "UNKNOWN"
    },
    
    timestamp: new Date().toISOString(),
    workflow_step: "forex_execution_complete",
    workflow_version: "enhanced-v2.0"
  }
}];`
      },
      "name": "💱 Trade Executor",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1020, 20]
    },

    // ===== NODE 7: PORTFOLIO & PERFORMANCE TRACKER =====
    {
      "parameters": {
        "functionCode": `
// 📊 PORTFOLIO & PERFORMANCE TRACKER
console.log("📊 Starting Portfolio & Performance Tracking...");

const executionData = $json;

// Update portfolio metrics
const portfolioMetrics = {
  forex_positions: executionData.executed_trades?.length || 0,
  total_forex_exposure: executionData.portfolio_update?.total_allocation || 0,
  session: executionData.session,
  last_update: new Date().toISOString(),
  
  // Risk metrics
  risk_level: executionData.portfolio_update?.total_allocation > 0.06 ? "HIGH" : 
             executionData.portfolio_update?.total_allocation > 0.03 ? "MEDIUM" : "LOW",
  
  // Session performance
  session_performance: {
    session: executionData.session,
    trades_executed: executionData.executed_trades?.length || 0,
    avg_confidence: executionData.performance_data?.avg_confidence || 0,
    execution_rate: (executionData.performance_data?.execution_rate || 0) * 100,
    avg_slippage: executionData.performance_data?.avg_slippage || 0
  }
};

// Performance tracking for AI feedback loops
const performanceFeedback = {
  strategy: "forex_sessions",
  session: executionData.session,
  timestamp: new Date().toISOString(),
  
  // Execution metrics
  trades_planned: executionData.summary?.total_planned || 0,
  trades_executed: executionData.summary?.total_executed || 0,
  execution_success_rate: executionData.summary?.execution_success_rate || 0,
  
  // Quality metrics
  avg_technical_score: executionData.executed_trades?.reduce((sum, trade) => 
    sum + trade.technical_score, 0) / (executionData.executed_trades?.length || 1),
  avg_confidence: executionData.performance_data?.avg_confidence || 0,
  session_strength: executionData.performance_data?.session_strength || "UNKNOWN",
  
  // Risk metrics
  total_allocation: portfolioMetrics.total_forex_exposure,
  avg_slippage_pips: executionData.summary?.avg_slippage_pips || 0,
  risk_level: portfolioMetrics.risk_level,
  
  // Market context
  market_session: executionData.session,
  workflow_version: "enhanced-v2.0"
};

// Generate insights for next session
const sessionInsights = {
  session: executionData.session,
  profitability_prediction: portfolioMetrics.session_performance.avg_confidence > 70 ? "HIGH" : "MEDIUM",
  recommended_allocation: Math.min(0.10, portfolioMetrics.total_forex_exposure * 1.2), // Increase if successful
  next_session_focus: executionData.session === "LONDON" ? "NEW_YORK" : 
                     executionData.session === "NEW_YORK" ? "ASIA" : "LONDON",
  
  // Learning points
  lessons_learned: [
    executionData.summary?.execution_success_rate > 90 ? "High execution quality maintained" : "Consider optimizing execution",
    portfolioMetrics.session_performance.avg_confidence > 70 ? "Strong signal quality" : "Review confidence thresholds",
    executionData.summary?.avg_slippage_pips < 0.5 ? "Excellent slippage control" : "Monitor slippage impact"
  ].filter(lesson => lesson)
};

console.log(\`📊 Portfolio updated: \${portfolioMetrics.forex_positions} positions, \${(portfolioMetrics.total_forex_exposure * 100).toFixed(1)}% allocation\`);

return [{
  json: {
    workflow_type: "forex_enhanced",
    workflow_result: "COMPLETE",
    session: executionData.session,
    
    // Portfolio state
    portfolio_metrics: portfolioMetrics,
    performance_feedback: performanceFeedback,
    session_insights: sessionInsights,
    
    // Execution summary
    execution_summary: {
      session: executionData.session,
      decision: executionData.execution_result,
      trades_executed: executionData.executed_trades?.length || 0,
      portfolio_allocation: portfolioMetrics.total_forex_exposure,
      risk_level: portfolioMetrics.risk_level,
      timestamp: new Date().toISOString()
    },
    
    // AI Orchestrator feedback
    orchestrator_feedback: {
      strategy: "forex_sessions",
      success: executionData.execution_result === "COMPLETE",
      confidence: performanceFeedback.avg_confidence,
      allocation_used: portfolioMetrics.total_forex_exposure,
      session_optimal: executionData.session !== "QUIET",
      next_recommendation: "continue_monitoring"
    },
    
    final_timestamp: new Date().toISOString(),
    workflow_version: "enhanced-v2.0"
  }
}];`
      },
      "name": "📊 Portfolio Tracker",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1220, 20]
    }
  ],
  
  "connections": {
    "💱 Forex Webhook Trigger": {
      "main": [
        [
          {
            "node": "🌍 Session Detector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🌍 Session Detector": {
      "main": [
        [
          {
            "node": "💱 Forex Scanner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "💱 Forex Scanner": {
      "main": [
        [
          {
            "node": "📊 Technical Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "📊 Technical Analysis": {
      "main": [
        [
          {
            "node": "🎯 Decision Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🎯 Decision Engine": {
      "main": [
        [
          {
            "node": "💱 Trade Executor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "💱 Trade Executor": {
      "main": [
        [
          {
            "node": "📊 Portfolio Tracker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  
  "active": true,
  "settings": {},
  "versionId": "enhanced-forex-v2.0",
  "id": "forex-enhanced-trading",
  "meta": {
    "instanceId": "advanced-trading-ai"
  },
  "tags": ["forex", "trading", "ai", "enhanced", "sessions"]
} 