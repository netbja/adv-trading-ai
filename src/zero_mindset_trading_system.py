#!/usr/bin/env python3
"""
ü§ñ SYST√àME TRADING 100% AUTOMATIQUE - ZERO MINDSET
√âlimine compl√®tement les √©motions et d√©cisions humaines du trading
Tu n'as plus besoin de "mindset" - tout est automatis√© !
"""

import asyncio
import json
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging

# Imports de nos syst√®mes existants
from src.infrastructure.rpc_optimizer import AutoTradingRPCManager
from src.monitoring.progression_monitor import ProgressionMonitor

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TradingEmotionBlocker:
    """Bloque toutes les √©motions de trading"""
    
    BLOCKED_EMOTIONS = [
        "fear", "greed", "fomo", "panic", "euphoria", 
        "regret", "hope", "anxiety", "excitement", "doubt"
    ]
    
    @staticmethod
    def process_decision(decision_data: Dict) -> Dict:
        """Traite une d√©cision en bloquant toute √©motion"""
        # Supprimer toutes les consid√©rations √©motionnelles
        clean_decision = {
            "action": decision_data.get("action"),
            "amount": decision_data.get("amount"),
            "reasoning": "D√©cision automatique bas√©e sur donn√©es",
            "confidence": decision_data.get("confidence", 1.0),
            "risk_level": decision_data.get("risk_level"),
            "emotional_state": "BLOCKED",
            "human_override": False
        }
        
        return clean_decision
        
    @staticmethod
    def validate_no_emotion(decision: Dict) -> bool:
        """Valide qu'aucune √©motion n'interf√®re"""
        decision_text = json.dumps(decision).lower()
        
        for emotion in TradingEmotionBlocker.BLOCKED_EMOTIONS:
            if emotion in decision_text:
                logger.warning(f"üö´ √âmotion d√©tect√©e et bloqu√©e: {emotion}")
                return False
                
        return True

class AutoInvestmentDecisionEngine:
    """Moteur de d√©cision d'investissement automatique"""
    
    def __init__(self):
        self.progression_monitor = ProgressionMonitor()
        self.rpc_manager = AutoTradingRPCManager()
        self.emotion_blocker = TradingEmotionBlocker()
        
        # R√®gles d'investissement automatique strictes
        self.investment_rules = {
            "apis_premium": {
                "trigger_conditions": {
                    "min_decisions": 50,
                    "min_win_rate": 0.80,
                    "min_duration_days": 14,
                    "max_drawdown": 0.10,
                    "min_stability": 0.90
                },
                "budget": 200,  # ‚Ç¨/mois
                "auto_execute": True,
                "confidence_threshold": 0.95
            },
            "micro_trading": {
                "trigger_conditions": {
                    "min_decisions": 100,
                    "min_win_rate": 0.85,
                    "min_duration_days": 28,
                    "max_drawdown": 0.08,
                    "api_stability": 0.95
                },
                "budget": 300,  # ‚Ç¨ capital
                "auto_execute": True,
                "confidence_threshold": 0.98
            },
            "serious_trading": {
                "trigger_conditions": {
                    "min_decisions": 200,
                    "min_win_rate": 0.75,
                    "min_duration_days": 60,
                    "consecutive_profitable_months": 3,
                    "sharpe_ratio": 1.5
                },
                "budget": 3000,  # ‚Ç¨ capital
                "auto_execute": False,  # Requires explicit confirmation
                "confidence_threshold": 0.99
            }
        }
        
    async def auto_evaluate_investment_readiness(self) -> Dict:
        """√âvalue automatiquement la pr√©paration pour investir"""
        logger.info("ü§ñ √âvaluation automatique de pr√©paration investissement...")
        
        # Obtenir m√©triques actuelles
        current_metrics = await self._get_current_performance_metrics()
        
        # √âvaluer chaque phase d'investissement
        evaluations = {}
        for phase, rules in self.investment_rules.items():
            evaluation = self._evaluate_phase_readiness(phase, current_metrics, rules)
            evaluations[phase] = evaluation
            
        # D√©cision automatique finale
        final_decision = self._make_automatic_investment_decision(evaluations)
        
        return {
            "evaluation_timestamp": datetime.now(),
            "current_metrics": current_metrics,
            "phase_evaluations": evaluations,
            "automatic_decision": final_decision,
            "emotional_interference": "BLOCKED",
            "human_decision_required": final_decision.get("requires_human_approval", False)
        }
        
    def _evaluate_phase_readiness(self, phase: str, metrics: Dict, rules: Dict) -> Dict:
        """√âvalue la pr√©paration pour une phase sp√©cifique"""
        conditions = rules["trigger_conditions"]
        met_conditions = []
        failed_conditions = []
        
        # V√©rifier chaque condition
        for condition, threshold in conditions.items():
            current_value = metrics.get(condition, 0)
            
            if condition.startswith("min_"):
                condition_met = current_value >= threshold
            elif condition.startswith("max_"):
                condition_met = current_value <= threshold
            else:
                condition_met = current_value >= threshold
                
            if condition_met:
                met_conditions.append({
                    "condition": condition,
                    "required": threshold,
                    "current": current_value,
                    "status": "MET"
                })
            else:
                failed_conditions.append({
                    "condition": condition,
                    "required": threshold,
                    "current": current_value,
                    "status": "FAILED",
                    "gap": threshold - current_value if condition.startswith("min_") else current_value - threshold
                })
                
        all_conditions_met = len(failed_conditions) == 0
        confidence_score = len(met_conditions) / (len(met_conditions) + len(failed_conditions))
        
        return {
            "phase": phase,
            "ready": all_conditions_met,
            "confidence": confidence_score,
            "budget_required": rules["budget"],
            "auto_execute": rules["auto_execute"],
            "met_conditions": met_conditions,
            "failed_conditions": failed_conditions,
            "recommendation": self._generate_phase_recommendation(phase, all_conditions_met, rules["budget"])
        }
        
    def _generate_phase_recommendation(self, phase: str, ready: bool, budget: int) -> str:
        """G√©n√®re une recommandation automatique"""
        if ready:
            return f"üöÄ AUTOMATIQUE: Pr√™t √† investir {budget}‚Ç¨ pour {phase}"
        else:
            return f"‚è≥ AUTOMATIQUE: Continue la simulation pour {phase}"
            
    def _make_automatic_investment_decision(self, evaluations: Dict) -> Dict:
        """Prend une d√©cision automatique d'investissement"""
        # Trouver la prochaine phase pr√™te
        ready_phases = []
        for phase, eval_data in evaluations.items():
            if eval_data["ready"] and eval_data["confidence"] >= self.investment_rules[phase]["confidence_threshold"]:
                ready_phases.append((phase, eval_data))
                
        if ready_phases:
            # Prendre la premi√®re phase pr√™te
            next_phase, phase_data = ready_phases[0]
            
            decision = {
                "decision": "INVEST",
                "phase": next_phase,
                "budget": phase_data["budget_required"],
                "confidence": phase_data["confidence"],
                "auto_execute": phase_data["auto_execute"],
                "requires_human_approval": not phase_data["auto_execute"],
                "reasoning": f"Toutes conditions remplies pour {next_phase}",
                "risk_assessment": self._assess_automatic_risk(phase_data),
                "recommended_action": "Proc√©der √† l'investissement automatique" if phase_data["auto_execute"] else "Demander confirmation humaine"
            }
        else:
            decision = {
                "decision": "WAIT",
                "phase": None,
                "budget": 0,
                "confidence": 0.0,
                "auto_execute": False,
                "requires_human_approval": False,
                "reasoning": "Aucune phase pr√™te pour investissement",
                "recommended_action": "Continuer la simulation"
            }
            
        # Nettoyer la d√©cision de toute √©motion
        clean_decision = self.emotion_blocker.process_decision(decision)
        
        return clean_decision
        
    def _assess_automatic_risk(self, phase_data: Dict) -> str:
        """√âvalue automatiquement le risque"""
        confidence = phase_data["confidence"]
        
        if confidence >= 0.99:
            return "üü¢ TR√àS FAIBLE - Toutes m√©triques excellentes"
        elif confidence >= 0.95:
            return "üü° FAIBLE - M√©triques tr√®s bonnes"
        elif confidence >= 0.90:
            return "üü† MOD√âR√â - M√©triques acceptables"
        else:
            return "üî¥ √âLEV√â - M√©triques insuffisantes"
            
    async def _get_current_performance_metrics(self) -> Dict:
        """Obtient les m√©triques de performance actuelles"""
        # Simuler r√©cup√©ration des vraies m√©triques
        # Dans le vrai syst√®me, ceci se connecterait aux vraies donn√©es
        
        runtime = datetime.now() - datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        return {
            "min_decisions": 75,  # Simul√©
            "min_win_rate": 0.82,  # 82%
            "min_duration_days": 18,
            "max_drawdown": 0.06,  # 6%
            "min_stability": 0.94,  # 94%
            "api_stability": 0.97,  # 97%
            "consecutive_profitable_months": 2,
            "sharpe_ratio": 1.2,
            "last_updated": datetime.now()
        }

class ZeroMindsetTradingSystem:
    """Syst√®me de trading qui √©limine compl√®tement le besoin de mindset"""
    
    def __init__(self):
        self.investment_engine = AutoInvestmentDecisionEngine()
        self.rpc_manager = AutoTradingRPCManager()
        self.emotion_blocker = TradingEmotionBlocker()
        self.active = False
        
    async def initialize_anti_mindset_system(self) -> Dict:
        """Initialise le syst√®me anti-mindset"""
        logger.info("ü§ñ Initialisation du syst√®me ZERO MINDSET...")
        
        # 1. Optimiser automatiquement les RPC
        rpc_optimization = await self.rpc_manager.setup_for_zero_mindset_trading()
        
        # 2. √âvaluer pr√©paration investissement
        investment_readiness = await self.investment_engine.auto_evaluate_investment_readiness()
        
        # 3. Activer le syst√®me
        self.active = True
        
        system_status = {
            "system": "ZERO MINDSET TRADING",
            "status": "ACTIVE",
            "mindset_required": False,
            "emotional_decisions": "BLOCKED",
            "human_intervention": "MINIMIZED",
            "automation_level": "100%",
            "rpc_optimization": rpc_optimization,
            "investment_readiness": investment_readiness,
            "advantages": [
                "üö´ Aucune √©motion ne peut interf√©rer",
                "ü§ñ D√©cisions purement bas√©es sur donn√©es",
                "‚ö° Ex√©cution automatique instantan√©e",
                "üõ°Ô∏è Protection contre FOMO/Panic/Greed",
                "üìä Optimisation RPC automatique",
                "üí∞ Alertes d'investissement intelligentes",
                "üîÑ Auto-ajustement continu"
            ]
        }
        
        return system_status
        
    async def run_automated_trading_loop(self):
        """Boucle de trading automatique sans intervention humaine"""
        logger.info("üîÑ D√©marrage boucle trading automatique...")
        
        if not self.active:
            await self.initialize_anti_mindset_system()
            
        cycle = 0
        while self.active:
            try:
                cycle += 1
                logger.info(f"üîÑ Cycle automatique #{cycle}")
                
                # 1. √âvaluer situation automatiquement
                evaluation = await self.investment_engine.auto_evaluate_investment_readiness()
                
                # 2. Prendre d√©cision automatique
                decision = evaluation["automatic_decision"]
                
                # 3. Valider absence d'√©motion
                if not self.emotion_blocker.validate_no_emotion(decision):
                    logger.warning("üö´ D√©cision rejet√©e - √©motion d√©tect√©e")
                    continue
                    
                # 4. Ex√©cuter si appropri√©
                if decision["decision"] == "INVEST" and decision["auto_execute"]:
                    await self._execute_automatic_investment(decision)
                elif decision["decision"] == "INVEST" and decision["requires_human_approval"]:
                    await self._request_human_approval(decision)
                    
                # 5. G√©n√©rer rapport de cycle
                await self._generate_cycle_report(cycle, evaluation, decision)
                
                # 6. Attendre avant prochain cycle
                await asyncio.sleep(30)  # 30 secondes entre cycles
                
            except Exception as e:
                logger.error(f"‚ùå Erreur dans cycle automatique: {e}")
                await asyncio.sleep(60)  # Wait longer on error
                
    async def _execute_automatic_investment(self, decision: Dict):
        """Ex√©cute automatiquement un investissement"""
        logger.info(f"üí∞ Ex√©cution automatique investissement: {decision['budget']}‚Ç¨ pour {decision['phase']}")
        
        # Dans un vrai syst√®me, ceci d√©clencherait l'achat d'APIs premium, etc.
        execution_result = {
            "executed": True,
            "phase": decision["phase"],
            "budget": decision["budget"],
            "timestamp": datetime.now(),
            "method": "automatic",
            "confidence": decision["confidence"]
        }
        
        logger.info(f"‚úÖ Investissement automatique ex√©cut√©: {execution_result}")
        return execution_result
        
    async def _request_human_approval(self, decision: Dict):
        """Demande approbation humaine pour gros investissements"""
        logger.warning(f"üë§ Approbation humaine requise pour {decision['budget']}‚Ç¨")
        
        print("\n" + "="*60)
        print("üö® APPROBATION HUMAINE REQUISE")
        print("="*60)
        print(f"üí∞ Budget: {decision['budget']}‚Ç¨")
        print(f"üìä Phase: {decision['phase']}")
        print(f"üéØ Confiance: {decision['confidence']:.1%}")
        print(f"‚öñÔ∏è Risque: {decision['risk_assessment']}")
        print(f"üí° Recommandation: {decision['recommended_action']}")
        print("="*60)
        
        # Attendre approbation (dans un vrai syst√®me, ceci serait via UI/notification)
        print("‚è≥ En attente d'approbation humaine...")
        
    async def _generate_cycle_report(self, cycle: int, evaluation: Dict, decision: Dict):
        """G√©n√®re un rapport de cycle"""
        metrics = evaluation["current_metrics"]
        
        if cycle % 10 == 0:  # Rapport d√©taill√© tous les 10 cycles
            print(f"\nüìä RAPPORT AUTOMATIQUE - CYCLE #{cycle}")
            print(f"‚è∞ {datetime.now().strftime('%H:%M:%S')}")
            print(f"üéØ D√©cisions: {metrics['min_decisions']}")
            print(f"üìà Win Rate: {metrics['min_win_rate']:.1%}")
            print(f"‚öñÔ∏è Risque: {decision.get('risk_assessment', 'N/A')}")
            print(f"ü§ñ D√©cision: {decision['decision']}")
            print(f"üí∞ Budget pr√™t: {decision.get('budget', 0)}‚Ç¨")
            
    def emergency_stop(self):
        """Arr√™t d'urgence du syst√®me"""
        logger.warning("üõë ARR√äT D'URGENCE ACTIV√â")
        self.active = False
        
    def get_system_status(self) -> Dict:
        """Obtient le statut du syst√®me"""
        return {
            "active": self.active,
            "mindset_eliminated": True,
            "emotional_trading": "BLOCKED",
            "automation_level": "100%",
            "human_intervention_required": False,
            "last_check": datetime.now()
        }

# Interface de lancement simple
async def launch_zero_mindset_system():
    """Lance le syst√®me de trading sans mindset"""
    print("ü§ñ LANCEMENT SYST√àME TRADING ZERO MINDSET")
    print("="*50)
    print("‚úÖ Plus besoin de mindset - tout est automatis√©!")
    print("üö´ √âmotions bloqu√©es automatiquement")
    print("üí° D√©cisions bas√©es uniquement sur donn√©es")
    print("‚ö° Ex√©cution automatique optimale")
    print("="*50)
    
    system = ZeroMindsetTradingSystem()
    
    # Initialisation
    status = await system.initialize_anti_mindset_system()
    print("\nüöÄ INITIALISATION TERMIN√âE:")
    print(json.dumps(status, indent=2, default=str))
    
    # Lancer la boucle automatique
    try:
        await system.run_automated_trading_loop()
    except KeyboardInterrupt:
        print("\nüõë Arr√™t demand√©")
        system.emergency_stop()
        
        final_status = system.get_system_status()
        print("\nüìä STATUT FINAL:")
        print(json.dumps(final_status, indent=2, default=str))

# Point d'entr√©e principal
def main():
    """Point d'entr√©e"""
    print("üéØ Choix du mode:")
    print("1. ü§ñ Syst√®me Zero Mindset (recommand√©)")
    print("2. üìä Test √©valuation seule")
    print("3. üîß Test optimisation RPC")
    
    choice = input("\nTon choix (1-3): ").strip()
    
    if choice == "1":
        asyncio.run(launch_zero_mindset_system())
    elif choice == "2":
        async def test_evaluation():
            engine = AutoInvestmentDecisionEngine()
            result = await engine.auto_evaluate_investment_readiness()
            print(json.dumps(result, indent=2, default=str))
        asyncio.run(test_evaluation())
    elif choice == "3":
        from src.infrastructure.rpc_optimizer import test_rpc_optimization
        asyncio.run(test_rpc_optimization())
    else:
        print("‚ùå Choix invalide")

if __name__ == "__main__":
    main() 